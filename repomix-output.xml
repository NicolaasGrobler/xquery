This file is a merged representation of the entire codebase, combined into a single document by Repomix.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
5. Multiple file entries, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

</file_summary>

<directory_structure>
.claude/CLAUDE.md
.claude/settings.local.json
.dockerignore
.gitignore
.husky/pre-commit
apps/server/.env.example
apps/server/.gitignore
apps/server/package.json
apps/server/src/index.ts
apps/server/tsconfig.json
apps/server/tsdown.config.ts
apps/web/.env.example
apps/web/.gitignore
apps/web/components.json
apps/web/index.html
apps/web/package.json
apps/web/public/favicon.ico
apps/web/src/components/error-boundary.tsx
apps/web/src/components/files/file-list.tsx
apps/web/src/components/files/file-upload-dialog.tsx
apps/web/src/components/files/file-upload-form.tsx
apps/web/src/components/keyboard-shortcuts-dialog.tsx
apps/web/src/components/loader.tsx
apps/web/src/components/mode-toggle.tsx
apps/web/src/components/motion/fade-in.tsx
apps/web/src/components/motion/index.ts
apps/web/src/components/motion/stagger-container.tsx
apps/web/src/components/motion/stagger-item.tsx
apps/web/src/components/sidebar.tsx
apps/web/src/components/sign-in-form.tsx
apps/web/src/components/sign-up-form.tsx
apps/web/src/components/theme-provider.tsx
apps/web/src/components/ui/alert-dialog.tsx
apps/web/src/components/ui/button.test.tsx
apps/web/src/components/ui/button.tsx
apps/web/src/components/ui/card.tsx
apps/web/src/components/ui/checkbox.tsx
apps/web/src/components/ui/dialog.tsx
apps/web/src/components/ui/dropdown-menu.tsx
apps/web/src/components/ui/input.tsx
apps/web/src/components/ui/label.tsx
apps/web/src/components/ui/scroll-area.tsx
apps/web/src/components/ui/skeleton.tsx
apps/web/src/components/ui/sonner.tsx
apps/web/src/components/user-menu.tsx
apps/web/src/hooks/use-hotkeys.test.ts
apps/web/src/hooks/use-hotkeys.ts
apps/web/src/hooks/use-reduced-motion.ts
apps/web/src/index.css
apps/web/src/lib/auth-client.ts
apps/web/src/lib/motion.ts
apps/web/src/lib/utils.test.ts
apps/web/src/lib/utils.ts
apps/web/src/main.tsx
apps/web/src/routes/__root.tsx
apps/web/src/routes/chat.$chatId.tsx
apps/web/src/routes/chat.tsx
apps/web/src/routes/dashboard.tsx
apps/web/src/routes/files.tsx
apps/web/src/routes/index.tsx
apps/web/src/routes/login.tsx
apps/web/src/routeTree.gen.ts
apps/web/src/test/setup.ts
apps/web/src/utils/trpc.ts
apps/web/tsconfig.json
apps/web/vercel.json
apps/web/vite.config.ts
apps/web/vitest.config.ts
biome.json
bts.jsonc
bunfig.toml
Dockerfile
nul
package.json
packages/api/.gitignore
packages/api/package.json
packages/api/src/context.ts
packages/api/src/index.test.ts
packages/api/src/index.ts
packages/api/src/lib/openai.ts
packages/api/src/routers/chat.ts
packages/api/src/routers/files.ts
packages/api/src/routers/index.ts
packages/api/src/streaming.ts
packages/api/tsconfig.json
packages/api/vitest.config.ts
packages/auth/.gitignore
packages/auth/package.json
packages/auth/src/index.ts
packages/auth/tsconfig.json
packages/config/package.json
packages/config/tsconfig.base.json
packages/db/.gitignore
packages/db/drizzle.config.ts
packages/db/package.json
packages/db/src/index.ts
packages/db/src/migrations/0000_giant_komodo.sql
packages/db/src/migrations/0001_violet_wildside.sql
packages/db/src/migrations/meta/_journal.json
packages/db/src/migrations/meta/0000_snapshot.json
packages/db/src/migrations/meta/0001_snapshot.json
packages/db/src/schema/auth.ts
packages/db/src/schema/chat.ts
packages/db/src/schema/files.ts
packages/db/src/supabase.ts
packages/db/supabase/.branches/_current_branch
packages/db/supabase/.temp/cli-latest
packages/db/supabase/config.toml
packages/db/tsconfig.json
README.md
supabase/.branches/_current_branch
supabase/.temp/cli-latest
turbo.json
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path="nul">
C\:\\Users\\Nicol\\OneDrive\\Documents\\Development\\Xenet\\xquery\\packages:
api  auth  config  db
</file>

<file path=".claude/CLAUDE.md">
# Ultracite Code Standards

This project uses **Ultracite**, a zero-config Biome preset that enforces strict code quality standards through automated formatting and linting.

## Quick Reference

- **Format code**: `npx ultracite fix`
- **Check for issues**: `npx ultracite check`
- **Diagnose setup**: `npx ultracite doctor`

Biome (the underlying engine) provides extremely fast Rust-based linting and formatting. Most issues are automatically fixable.

---

## Core Principles

Write code that is **accessible, performant, type-safe, and maintainable**. Focus on clarity and explicit intent over brevity.

### Type Safety & Explicitness

- Use explicit types for function parameters and return values when they enhance clarity
- Prefer `unknown` over `any` when the type is genuinely unknown
- Use const assertions (`as const`) for immutable values and literal types
- Leverage TypeScript's type narrowing instead of type assertions
- Use meaningful variable names instead of magic numbers - extract constants with descriptive names

### Modern JavaScript/TypeScript

- Use arrow functions for callbacks and short functions
- Prefer `for...of` loops over `.forEach()` and indexed `for` loops
- Use optional chaining (`?.`) and nullish coalescing (`??`) for safer property access
- Prefer template literals over string concatenation
- Use destructuring for object and array assignments
- Use `const` by default, `let` only when reassignment is needed, never `var`

### Async & Promises

- Always `await` promises in async functions - don't forget to use the return value
- Use `async/await` syntax instead of promise chains for better readability
- Handle errors appropriately in async code with try-catch blocks
- Don't use async functions as Promise executors

### React & JSX

- Use function components over class components
- Call hooks at the top level only, never conditionally
- Specify all dependencies in hook dependency arrays correctly
- Use the `key` prop for elements in iterables (prefer unique IDs over array indices)
- Nest children between opening and closing tags instead of passing as props
- Don't define components inside other components
- Use semantic HTML and ARIA attributes for accessibility:
  - Provide meaningful alt text for images
  - Use proper heading hierarchy
  - Add labels for form inputs
  - Include keyboard event handlers alongside mouse events
  - Use semantic elements (`<button>`, `<nav>`, etc.) instead of divs with roles

### Error Handling & Debugging

- Remove `console.log`, `debugger`, and `alert` statements from production code
- Throw `Error` objects with descriptive messages, not strings or other values
- Use `try-catch` blocks meaningfully - don't catch errors just to rethrow them
- Prefer early returns over nested conditionals for error cases

### Code Organization

- Keep functions focused and under reasonable cognitive complexity limits
- Extract complex conditions into well-named boolean variables
- Use early returns to reduce nesting
- Prefer simple conditionals over nested ternary operators
- Group related code together and separate concerns

### Security

- Add `rel="noopener"` when using `target="_blank"` on links
- Avoid `dangerouslySetInnerHTML` unless absolutely necessary
- Don't use `eval()` or assign directly to `document.cookie`
- Validate and sanitize user input

### Performance

- Avoid spread syntax in accumulators within loops
- Use top-level regex literals instead of creating them in loops
- Prefer specific imports over namespace imports
- Avoid barrel files (index files that re-export everything)
- Use proper image components (e.g., Next.js `<Image>`) over `<img>` tags

### Framework-Specific Guidance

**Next.js:**
- Use Next.js `<Image>` component for images
- Use `next/head` or App Router metadata API for head elements
- Use Server Components for async data fetching instead of async Client Components

**React 19+:**
- Use ref as a prop instead of `React.forwardRef`

**Solid/Svelte/Vue/Qwik:**
- Use `class` and `for` attributes (not `className` or `htmlFor`)

---

## Testing

- Write assertions inside `it()` or `test()` blocks
- Avoid done callbacks in async tests - use async/await instead
- Don't use `.only` or `.skip` in committed code
- Keep test suites reasonably flat - avoid excessive `describe` nesting

## When Biome Can't Help

Biome's linter will catch most issues automatically. Focus your attention on:

1. **Business logic correctness** - Biome can't validate your algorithms
2. **Meaningful naming** - Use descriptive names for functions, variables, and types
3. **Architecture decisions** - Component structure, data flow, and API design
4. **Edge cases** - Handle boundary conditions and error states
5. **User experience** - Accessibility, performance, and usability considerations
6. **Documentation** - Add comments for complex logic, but prefer self-documenting code

---

Most formatting and common issues are automatically fixed by Biome. Run `npx ultracite fix` before committing to ensure compliance.
</file>

<file path=".dockerignore">
# Dependencies
node_modules
**/node_modules

# Build outputs
dist
**/dist
.turbo
**/.turbo

# Git
.git
.gitignore

# IDE
.vscode
.idea

# Environment files (use docker secrets or env vars)
.env
.env.*
!.env.example

# Misc
*.md
*.log
coverage
.husky
supabase
</file>

<file path=".gitignore">
# Dependencies
node_modules
.pnp
.pnp.js

# Build outputs
dist
build
*.tsbuildinfo

# Environment variables
.env
.env*.local

# IDEs and editors
.vscode/*
!.vscode/settings.json
!.vscode/tasks.json
!.vscode/launch.json
!.vscode/extensions.json
.idea
*.swp
*.swo
*~
.DS_Store

# Logs
logs
*.log
npm-debug.log*
yarn-debug.log*
yarn-error.log*
lerna-debug.log*
.pnpm-debug.log*

# Turbo
.turbo

# Better-T-Stack
.alchemy

# Testing
coverage
.nyc_output

# Misc
*.tgz
.cache
tmp
temp
</file>

<file path="apps/server/.gitignore">
# prod
dist/
/build
/out/

# dev
.yarn/
!.yarn/patches
!.yarn/plugins
!.yarn/releases
!.yarn/versions
.vscode/*
!.vscode/launch.json
!.vscode/*.code-snippets
.idea/workspace.xml
.idea/usage.statistics.xml
.idea/shelf
.wrangler
.alchemy
/.next/
.vercel
prisma/generated/


# deps
node_modules/
/node_modules
/.pnp
.pnp.*

# env
.env*
.env.production
!.env.example
.dev.vars

# logs
logs/
*.log
npm-debug.log*
yarn-debug.log*
yarn-error.log*
pnpm-debug.log*
lerna-debug.log*

# misc
.DS_Store
*.pem

# local db
*.db*

# typescript
*.tsbuildinfo
next-env.d.ts
</file>

<file path="apps/server/package.json">
{
  "name": "server",
  "main": "src/index.ts",
  "type": "module",
  "scripts": {
    "build": "tsdown",
    "check-types": "tsc -b",
    "compile": "bun build --compile --minify --sourcemap --bytecode ./src/index.ts --outfile server",
    "dev": "bun run --hot src/index.ts",
    "start": "bun run dist/index.js"
  },
  "dependencies": {
    "hono": "catalog:",
    "@trpc/server": "catalog:",
    "@hono/trpc-server": "^0.4.0",
    "better-auth": "catalog:",
    "dotenv": "catalog:",
    "zod": "catalog:",
    "@xquery/api": "workspace:*",
    "@xquery/auth": "workspace:*",
    "@xquery/db": "workspace:*"
  },
  "trustedDependencies": [
    "supabase"
  ],
  "devDependencies": {
    "typescript": "^5.8.2",
    "@types/bun": "^1.2.6",
    "tsdown": "^0.16.5",
    "@xquery/config": "workspace:*"
  }
}
</file>

<file path="apps/web/.env.example">
VITE_SERVER_URL=
</file>

<file path="apps/web/.gitignore">
# Dependencies
/node_modules
/.pnp
.pnp.*
.yarn/*
!.yarn/patches
!.yarn/plugins
!.yarn/releases
!.yarn/versions

# Testing
/coverage

# Build outputs
/.next/
/out/
/build/
/dist/
.vinxi
.output
.react-router/
.tanstack/
.nitro/

# Deployment
.vercel
.netlify
.wrangler
.alchemy

# Environment & local files
.env*
!.env.example
.DS_Store
*.pem
*.local

# Logs
npm-debug.log*
yarn-debug.log*
yarn-error.log*
.pnpm-debug.log*
*.log*

# TypeScript
*.tsbuildinfo
next-env.d.ts

# IDE
.vscode/*
!.vscode/extensions.json
.idea

# Other
dev-dist

.wrangler
.dev.vars*

.open-next
</file>

<file path="apps/web/src/components/error-boundary.tsx">
import { type ErrorComponentProps, Link } from "@tanstack/react-router";
import { AlertCircle, Home, RefreshCw, RotateCcw } from "lucide-react";
import { Button } from "@/components/ui/button";
import {
  Card,
  CardContent,
  CardDescription,
  CardFooter,
  CardHeader,
  CardTitle,
} from "@/components/ui/card";

export function ErrorBoundary({ error, reset }: ErrorComponentProps) {
  return (
    <div className="flex h-full min-h-[50vh] items-center justify-center p-4">
      <Card className="w-full max-w-md">
        <CardHeader className="text-center">
          <div className="mx-auto mb-2 flex h-12 w-12 items-center justify-center rounded-full bg-destructive/10">
            <AlertCircle className="h-6 w-6 text-destructive" />
          </div>
          <CardTitle className="text-xl">Something went wrong</CardTitle>
          <CardDescription>
            {error.message || "An unexpected error occurred"}
          </CardDescription>
        </CardHeader>
        {import.meta.env.DEV && error.stack && (
          <CardContent>
            <pre className="max-h-[150px] overflow-auto rounded-md bg-muted p-3 font-mono text-xs">
              {error.stack}
            </pre>
          </CardContent>
        )}
        <CardFooter className="flex justify-center gap-2">
          <Button onClick={() => window.location.reload()} variant="outline">
            <RefreshCw className="h-4 w-4" />
            Reload
          </Button>
          {reset && (
            <Button onClick={reset}>
              <RotateCcw className="h-4 w-4" />
              Try again
            </Button>
          )}
        </CardFooter>
      </Card>
    </div>
  );
}

export function NotFound() {
  return (
    <div className="flex h-full min-h-[50vh] items-center justify-center p-4">
      <Card className="w-full max-w-md">
        <CardHeader className="text-center">
          <div className="mx-auto mb-2 font-bold text-6xl text-muted-foreground/50">
            404
          </div>
          <CardTitle className="text-xl">Page not found</CardTitle>
          <CardDescription>
            The page you're looking for doesn't exist or has been moved.
          </CardDescription>
        </CardHeader>
        <CardFooter className="flex justify-center gap-2">
          <Button onClick={() => window.history.back()} variant="outline">
            <RotateCcw className="h-4 w-4" />
            Go back
          </Button>
          <Button asChild>
            <Link to="/dashboard">
              <Home className="h-4 w-4" />
              Dashboard
            </Link>
          </Button>
        </CardFooter>
      </Card>
    </div>
  );
}
</file>

<file path="apps/web/src/components/motion/fade-in.tsx">
import type { HTMLMotionProps } from "framer-motion";
import { motion } from "framer-motion";
import type { ReactNode } from "react";
import { useReducedMotion } from "@/hooks/use-reduced-motion";
import { fadeUpVariants } from "@/lib/motion";

type FadeInProps = Omit<HTMLMotionProps<"div">, "children"> & {
  children: ReactNode;
  delay?: number;
};

export function FadeIn({
  children,
  delay = 0,
  className,
  ...props
}: FadeInProps) {
  const prefersReducedMotion = useReducedMotion();

  if (prefersReducedMotion) {
    return (
      <div
        className={className}
        {...(props as React.HTMLAttributes<HTMLDivElement>)}
      >
        {children}
      </div>
    );
  }

  return (
    <motion.div
      animate="visible"
      className={className}
      initial="hidden"
      transition={{ delay }}
      variants={fadeUpVariants}
      {...props}
    >
      {children}
    </motion.div>
  );
}
</file>

<file path="apps/web/src/components/motion/index.ts">
export { FadeIn } from "./fade-in";
export { StaggerContainer } from "./stagger-container";
export { StaggerItem } from "./stagger-item";
</file>

<file path="apps/web/src/components/motion/stagger-container.tsx">
import type { HTMLMotionProps } from "framer-motion";
import { motion } from "framer-motion";
import type { ReactNode } from "react";
import { useReducedMotion } from "@/hooks/use-reduced-motion";
import { staggerContainerVariants } from "@/lib/motion";

type StaggerContainerProps = Omit<HTMLMotionProps<"div">, "children"> & {
  children: ReactNode;
};

export function StaggerContainer({
  children,
  className,
  ...props
}: StaggerContainerProps) {
  const prefersReducedMotion = useReducedMotion();

  if (prefersReducedMotion) {
    return (
      <div
        className={className}
        {...(props as React.HTMLAttributes<HTMLDivElement>)}
      >
        {children}
      </div>
    );
  }

  return (
    <motion.div
      animate="visible"
      className={className}
      initial="hidden"
      variants={staggerContainerVariants}
      {...props}
    >
      {children}
    </motion.div>
  );
}
</file>

<file path="apps/web/src/components/motion/stagger-item.tsx">
import type { HTMLMotionProps } from "framer-motion";
import { motion } from "framer-motion";
import type { ReactNode } from "react";
import { staggerItemVariants } from "@/lib/motion";

type StaggerItemProps = Omit<HTMLMotionProps<"div">, "children"> & {
  children: ReactNode;
};

export function StaggerItem({
  children,
  className,
  ...props
}: StaggerItemProps) {
  return (
    <motion.div className={className} variants={staggerItemVariants} {...props}>
      {children}
    </motion.div>
  );
}
</file>

<file path="apps/web/src/components/ui/alert-dialog.tsx">
import * as AlertDialogPrimitive from "@radix-ui/react-alert-dialog";
import type * as React from "react";
import { buttonVariants } from "@/components/ui/button";
import { cn } from "@/lib/utils";

function AlertDialog({
  ...props
}: React.ComponentProps<typeof AlertDialogPrimitive.Root>) {
  return <AlertDialogPrimitive.Root data-slot="alert-dialog" {...props} />;
}

function AlertDialogTrigger({
  ...props
}: React.ComponentProps<typeof AlertDialogPrimitive.Trigger>) {
  return (
    <AlertDialogPrimitive.Trigger data-slot="alert-dialog-trigger" {...props} />
  );
}

function AlertDialogPortal({
  ...props
}: React.ComponentProps<typeof AlertDialogPrimitive.Portal>) {
  return (
    <AlertDialogPrimitive.Portal data-slot="alert-dialog-portal" {...props} />
  );
}

function AlertDialogOverlay({
  className,
  ...props
}: React.ComponentProps<typeof AlertDialogPrimitive.Overlay>) {
  return (
    <AlertDialogPrimitive.Overlay
      className={cn(
        "data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 fixed inset-0 z-50 bg-black/50 data-[state=closed]:animate-out data-[state=open]:animate-in",
        className
      )}
      data-slot="alert-dialog-overlay"
      {...props}
    />
  );
}

function AlertDialogContent({
  className,
  ...props
}: React.ComponentProps<typeof AlertDialogPrimitive.Content>) {
  return (
    <AlertDialogPortal>
      <AlertDialogOverlay />
      <AlertDialogPrimitive.Content
        className={cn(
          "data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 fixed top-[50%] left-[50%] z-50 grid w-full max-w-[calc(100%-2rem)] translate-x-[-50%] translate-y-[-50%] gap-4 rounded-lg border bg-background p-6 shadow-lg duration-200 data-[state=closed]:animate-out data-[state=open]:animate-in sm:max-w-lg",
          className
        )}
        data-slot="alert-dialog-content"
        {...props}
      />
    </AlertDialogPortal>
  );
}

function AlertDialogHeader({
  className,
  ...props
}: React.ComponentProps<"div">) {
  return (
    <div
      className={cn("flex flex-col gap-2 text-center sm:text-left", className)}
      data-slot="alert-dialog-header"
      {...props}
    />
  );
}

function AlertDialogFooter({
  className,
  ...props
}: React.ComponentProps<"div">) {
  return (
    <div
      className={cn(
        "flex flex-col-reverse gap-2 sm:flex-row sm:justify-end",
        className
      )}
      data-slot="alert-dialog-footer"
      {...props}
    />
  );
}

function AlertDialogTitle({
  className,
  ...props
}: React.ComponentProps<typeof AlertDialogPrimitive.Title>) {
  return (
    <AlertDialogPrimitive.Title
      className={cn("font-semibold text-lg", className)}
      data-slot="alert-dialog-title"
      {...props}
    />
  );
}

function AlertDialogDescription({
  className,
  ...props
}: React.ComponentProps<typeof AlertDialogPrimitive.Description>) {
  return (
    <AlertDialogPrimitive.Description
      className={cn("text-muted-foreground text-sm", className)}
      data-slot="alert-dialog-description"
      {...props}
    />
  );
}

function AlertDialogAction({
  className,
  ...props
}: React.ComponentProps<typeof AlertDialogPrimitive.Action>) {
  return (
    <AlertDialogPrimitive.Action
      className={cn(buttonVariants(), className)}
      {...props}
    />
  );
}

function AlertDialogCancel({
  className,
  ...props
}: React.ComponentProps<typeof AlertDialogPrimitive.Cancel>) {
  return (
    <AlertDialogPrimitive.Cancel
      className={cn(buttonVariants({ variant: "outline" }), className)}
      {...props}
    />
  );
}

export {
  AlertDialog,
  AlertDialogPortal,
  AlertDialogOverlay,
  AlertDialogTrigger,
  AlertDialogContent,
  AlertDialogHeader,
  AlertDialogFooter,
  AlertDialogTitle,
  AlertDialogDescription,
  AlertDialogAction,
  AlertDialogCancel,
};
</file>

<file path="apps/web/src/components/ui/button.test.tsx">
import { render, screen } from "@testing-library/react";
import userEvent from "@testing-library/user-event";
import { describe, expect, it, vi } from "vitest";
import { Button } from "./button";

describe("Button", () => {
  it("renders with default props", () => {
    render(<Button>Click me</Button>);
    expect(
      screen.getByRole("button", { name: /click me/i })
    ).toBeInTheDocument();
  });

  it("applies variant classes correctly", () => {
    const { rerender } = render(<Button variant="default">Default</Button>);
    expect(screen.getByRole("button")).toHaveClass("bg-primary");

    rerender(<Button variant="destructive">Destructive</Button>);
    expect(screen.getByRole("button")).toHaveClass("bg-destructive");

    rerender(<Button variant="outline">Outline</Button>);
    expect(screen.getByRole("button")).toHaveClass("border");

    rerender(<Button variant="ghost">Ghost</Button>);
    expect(screen.getByRole("button")).toHaveClass("hover:bg-accent");
  });

  it("applies size classes correctly", () => {
    const { rerender } = render(<Button size="default">Default</Button>);
    expect(screen.getByRole("button")).toHaveClass("h-9");

    rerender(<Button size="sm">Small</Button>);
    expect(screen.getByRole("button")).toHaveClass("h-8");

    rerender(<Button size="lg">Large</Button>);
    expect(screen.getByRole("button")).toHaveClass("h-10");

    rerender(<Button size="icon">Icon</Button>);
    expect(screen.getByRole("button")).toHaveClass("size-9");
  });

  it("handles click events", async () => {
    const user = userEvent.setup();
    const handleClick = vi.fn();

    render(<Button onClick={handleClick}>Click me</Button>);
    await user.click(screen.getByRole("button"));

    expect(handleClick).toHaveBeenCalledTimes(1);
  });

  it("can be disabled", async () => {
    const user = userEvent.setup();
    const handleClick = vi.fn();

    render(
      <Button disabled onClick={handleClick}>
        Disabled
      </Button>
    );

    const button = screen.getByRole("button");
    expect(button).toBeDisabled();

    await user.click(button);
    expect(handleClick).not.toHaveBeenCalled();
  });

  it("accepts custom className", () => {
    render(<Button className="custom-class">Custom</Button>);
    expect(screen.getByRole("button")).toHaveClass("custom-class");
  });

  it("forwards ref correctly", () => {
    const ref = vi.fn();
    render(<Button ref={ref}>With ref</Button>);
    expect(ref).toHaveBeenCalled();
  });
});
</file>

<file path="apps/web/src/components/ui/scroll-area.tsx">
import * as ScrollAreaPrimitive from "@radix-ui/react-scroll-area";
import type * as React from "react";

import { cn } from "@/lib/utils";

function ScrollArea({
  className,
  children,
  ...props
}: React.ComponentProps<typeof ScrollAreaPrimitive.Root>) {
  return (
    <ScrollAreaPrimitive.Root
      className={cn("relative overflow-hidden", className)}
      data-slot="scroll-area"
      {...props}
    >
      <ScrollAreaPrimitive.Viewport
        className="[&>div]:!block size-full rounded-[inherit] outline-none transition-[color,box-shadow] focus-visible:outline-1 focus-visible:ring-[3px] focus-visible:ring-ring/50"
        data-slot="scroll-area-viewport"
      >
        {children}
      </ScrollAreaPrimitive.Viewport>
      <ScrollBar />
      <ScrollAreaPrimitive.Corner />
    </ScrollAreaPrimitive.Root>
  );
}

function ScrollBar({
  className,
  orientation = "vertical",
  ...props
}: React.ComponentProps<typeof ScrollAreaPrimitive.ScrollAreaScrollbar>) {
  return (
    <ScrollAreaPrimitive.ScrollAreaScrollbar
      className={cn(
        "flex touch-none select-none p-px transition-colors",
        orientation === "vertical" &&
          "h-full w-2.5 border-l border-l-transparent",
        orientation === "horizontal" &&
          "h-2.5 flex-col border-t border-t-transparent",
        className
      )}
      data-slot="scroll-area-scrollbar"
      orientation={orientation}
      {...props}
    >
      <ScrollAreaPrimitive.ScrollAreaThumb
        className="relative flex-1 rounded-full bg-border"
        data-slot="scroll-area-thumb"
      />
    </ScrollAreaPrimitive.ScrollAreaScrollbar>
  );
}

export { ScrollArea, ScrollBar };
</file>

<file path="apps/web/src/hooks/use-hotkeys.test.ts">
import { renderHook } from "@testing-library/react";
import { afterEach, beforeEach, describe, expect, it, vi } from "vitest";
import { useHotkeys } from "./use-hotkeys";

describe("useHotkeys", () => {
  beforeEach(() => {
    vi.spyOn(document, "addEventListener");
    vi.spyOn(document, "removeEventListener");
  });

  afterEach(() => {
    vi.restoreAllMocks();
  });

  it("registers keydown event listener on mount", () => {
    const callback = vi.fn();
    renderHook(() => useHotkeys([{ key: "a", callback }]));

    expect(document.addEventListener).toHaveBeenCalledWith(
      "keydown",
      expect.any(Function)
    );
  });

  it("removes keydown event listener on unmount", () => {
    const callback = vi.fn();
    const { unmount } = renderHook(() => useHotkeys([{ key: "a", callback }]));

    unmount();

    expect(document.removeEventListener).toHaveBeenCalledWith(
      "keydown",
      expect.any(Function)
    );
  });

  it("calls callback when matching key is pressed", () => {
    const callback = vi.fn();
    renderHook(() => useHotkeys([{ key: "a", callback }]));

    const event = new KeyboardEvent("keydown", { key: "a" });
    document.dispatchEvent(event);

    expect(callback).toHaveBeenCalledTimes(1);
  });

  it("does not call callback for non-matching key", () => {
    const callback = vi.fn();
    renderHook(() => useHotkeys([{ key: "a", callback }]));

    const event = new KeyboardEvent("keydown", { key: "b" });
    document.dispatchEvent(event);

    expect(callback).not.toHaveBeenCalled();
  });

  it("handles ctrl modifier correctly", () => {
    const callback = vi.fn();
    renderHook(() => useHotkeys([{ key: "s", ctrl: true, callback }]));

    // Without ctrl - should not trigger
    const eventWithoutCtrl = new KeyboardEvent("keydown", { key: "s" });
    document.dispatchEvent(eventWithoutCtrl);
    expect(callback).not.toHaveBeenCalled();

    // With ctrl - should trigger
    const eventWithCtrl = new KeyboardEvent("keydown", {
      key: "s",
      ctrlKey: true,
    });
    document.dispatchEvent(eventWithCtrl);
    expect(callback).toHaveBeenCalledTimes(1);
  });

  it("handles shift modifier correctly", () => {
    const callback = vi.fn();
    renderHook(() => useHotkeys([{ key: "a", shift: true, callback }]));

    // Without shift - should not trigger
    const eventWithoutShift = new KeyboardEvent("keydown", { key: "a" });
    document.dispatchEvent(eventWithoutShift);
    expect(callback).not.toHaveBeenCalled();

    // With shift - should trigger
    const eventWithShift = new KeyboardEvent("keydown", {
      key: "a",
      shiftKey: true,
    });
    document.dispatchEvent(eventWithShift);
    expect(callback).toHaveBeenCalledTimes(1);
  });

  it("respects enabled flag", () => {
    const callback = vi.fn();
    const { rerender } = renderHook(
      ({ enabled }) => useHotkeys([{ key: "a", callback, enabled }]),
      { initialProps: { enabled: true } }
    );

    // When enabled
    const event1 = new KeyboardEvent("keydown", { key: "a" });
    document.dispatchEvent(event1);
    expect(callback).toHaveBeenCalledTimes(1);

    // When disabled
    rerender({ enabled: false });
    const event2 = new KeyboardEvent("keydown", { key: "a" });
    document.dispatchEvent(event2);
    expect(callback).toHaveBeenCalledTimes(1); // Still 1, not called again
  });

  it("is case-insensitive for key matching", () => {
    const callback = vi.fn();
    renderHook(() => useHotkeys([{ key: "A", callback }]));

    const event = new KeyboardEvent("keydown", { key: "a" });
    document.dispatchEvent(event);

    expect(callback).toHaveBeenCalledTimes(1);
  });

  it("always triggers Escape even when input is focused", () => {
    const callback = vi.fn();
    renderHook(() => useHotkeys([{ key: "Escape", callback }]));

    // Create an input and focus it
    const input = document.createElement("input");
    document.body.appendChild(input);
    input.focus();

    const event = new KeyboardEvent("keydown", { key: "Escape" });
    Object.defineProperty(event, "target", { value: input });
    document.dispatchEvent(event);

    expect(callback).toHaveBeenCalledTimes(1);

    document.body.removeChild(input);
  });
});
</file>

<file path="apps/web/src/hooks/use-hotkeys.ts">
import { useEffect } from "react";

type HotkeyCallback = (event: KeyboardEvent) => void;

type HotkeyConfig = {
  key: string;
  ctrl?: boolean;
  meta?: boolean;
  shift?: boolean;
  callback: HotkeyCallback;
  enabled?: boolean;
};

export function useHotkeys(hotkeys: HotkeyConfig[]) {
  useEffect(() => {
    // biome-ignore lint/complexity/noExcessiveCognitiveComplexity: hotkey matching requires multiple conditions
    function handleKeyDown(event: KeyboardEvent) {
      const target = event.target as HTMLElement;
      const isInputFocused =
        target.tagName === "INPUT" ||
        target.tagName === "TEXTAREA" ||
        target.isContentEditable;

      for (const hotkey of hotkeys) {
        if (hotkey.enabled === false) {
          continue;
        }

        const keyMatch = event.key.toLowerCase() === hotkey.key.toLowerCase();
        const ctrlMatch = hotkey.ctrl
          ? event.ctrlKey || event.metaKey
          : !(event.ctrlKey || event.metaKey);
        const metaMatch = hotkey.meta ? event.metaKey : true;
        const shiftMatch = hotkey.shift ? event.shiftKey : !event.shiftKey;

        const needsModifier = hotkey.ctrl || hotkey.meta;
        const isEscape = hotkey.key.toLowerCase() === "escape";

        if (isInputFocused && !needsModifier && !isEscape) {
          continue;
        }

        if (keyMatch && ctrlMatch && metaMatch && shiftMatch) {
          event.preventDefault();
          hotkey.callback(event);
          break;
        }
      }
    }

    document.addEventListener("keydown", handleKeyDown);
    return () => document.removeEventListener("keydown", handleKeyDown);
  }, [hotkeys]);
}
</file>

<file path="apps/web/src/hooks/use-reduced-motion.ts">
import { useEffect, useState } from "react";

export function useReducedMotion(): boolean {
  const [prefersReducedMotion, setPrefersReducedMotion] = useState(() => {
    if (typeof window === "undefined") {
      return false;
    }
    return window.matchMedia("(prefers-reduced-motion: reduce)").matches;
  });

  useEffect(() => {
    const mediaQuery = window.matchMedia("(prefers-reduced-motion: reduce)");

    const handleChange = (event: MediaQueryListEvent) => {
      setPrefersReducedMotion(event.matches);
    };

    mediaQuery.addEventListener("change", handleChange);
    return () => mediaQuery.removeEventListener("change", handleChange);
  }, []);

  return prefersReducedMotion;
}
</file>

<file path="apps/web/src/lib/motion.ts">
import type { Transition, Variants } from "framer-motion";

const DURATION_FAST = 0.15;
const DURATION_NORMAL = 0.2;
const EASE_DEFAULT: [number, number, number, number] = [0.25, 0.1, 0.25, 1];

export const defaultTransition: Transition = {
  duration: DURATION_NORMAL,
  ease: EASE_DEFAULT,
};

export const fadeVariants: Variants = {
  hidden: { opacity: 0 },
  visible: {
    opacity: 1,
    transition: defaultTransition,
  },
  exit: {
    opacity: 0,
    transition: { duration: DURATION_FAST },
  },
};

export const fadeUpVariants: Variants = {
  hidden: {
    opacity: 0,
    y: 8,
  },
  visible: {
    opacity: 1,
    y: 0,
    transition: defaultTransition,
  },
  exit: {
    opacity: 0,
    y: -4,
    transition: { duration: DURATION_FAST },
  },
};

export const staggerContainerVariants: Variants = {
  hidden: { opacity: 1 },
  visible: {
    opacity: 1,
    transition: {
      staggerChildren: 0.05,
      delayChildren: 0.02,
    },
  },
};

export const staggerItemVariants: Variants = {
  hidden: {
    opacity: 0,
    y: 8,
  },
  visible: {
    opacity: 1,
    y: 0,
    transition: {
      duration: DURATION_NORMAL,
      ease: EASE_DEFAULT,
    },
  },
};

export const slideFromLeftVariants: Variants = {
  hidden: {
    opacity: 0,
    x: -16,
  },
  visible: {
    opacity: 1,
    x: 0,
    transition: defaultTransition,
  },
};

export const slideFromRightVariants: Variants = {
  hidden: {
    opacity: 0,
    x: 16,
  },
  visible: {
    opacity: 1,
    x: 0,
    transition: defaultTransition,
  },
};

export const scaleFadeVariants: Variants = {
  hidden: {
    opacity: 0,
    scale: 0.98,
  },
  visible: {
    opacity: 1,
    scale: 1,
    transition: defaultTransition,
  },
  exit: {
    opacity: 0,
    scale: 0.98,
    transition: { duration: DURATION_FAST },
  },
};
</file>

<file path="apps/web/src/lib/utils.test.ts">
import { describe, expect, it } from "vitest";
import { cn } from "./utils";

describe("cn utility", () => {
  it("merges class names correctly", () => {
    expect(cn("foo", "bar")).toBe("foo bar");
  });

  it("handles conditional classes", () => {
    expect(cn("foo", false, "baz")).toBe("foo baz");
    expect(cn("foo", "bar", "baz")).toBe("foo bar baz");
  });

  it("merges tailwind classes and resolves conflicts", () => {
    expect(cn("px-2 py-1", "px-4")).toBe("py-1 px-4");
    expect(cn("text-red-500", "text-blue-500")).toBe("text-blue-500");
  });

  it("handles undefined and null values", () => {
    expect(cn("foo", undefined, null, "bar")).toBe("foo bar");
  });

  it("handles arrays of classes", () => {
    expect(cn(["foo", "bar"], "baz")).toBe("foo bar baz");
  });

  it("handles empty inputs", () => {
    expect(cn()).toBe("");
    expect(cn("")).toBe("");
  });
});
</file>

<file path="apps/web/src/test/setup.ts">
import "@testing-library/jest-dom/vitest";
import { cleanup } from "@testing-library/react";
import { afterEach } from "vitest";

afterEach(() => {
  cleanup();
});
</file>

<file path="apps/web/vercel.json">
{
  "rewrites": [
    {
      "source": "/((?!assets/).*)",
      "destination": "/index.html"
    }
  ]
}
</file>

<file path="apps/web/vitest.config.ts">
import path from "node:path";
import react from "@vitejs/plugin-react";
import { defineConfig } from "vitest/config";

export default defineConfig({
  plugins: [react()],
  test: {
    environment: "happy-dom",
    globals: true,
    setupFiles: ["./src/test/setup.ts"],
    include: ["src/**/*.{test,spec}.{ts,tsx}"],
    coverage: {
      provider: "v8",
      reporter: ["text", "json", "html"],
      include: ["src/**/*.{ts,tsx}"],
      exclude: [
        "src/test/**",
        "src/routeTree.gen.ts",
        "src/main.tsx",
        "**/*.d.ts",
      ],
    },
  },
  resolve: {
    alias: {
      "@": path.resolve(__dirname, "./src"),
    },
  },
});
</file>

<file path="bts.jsonc">
// Better-T-Stack configuration file
// safe to delete

{
  "$schema": "https://r2.better-t-stack.dev/schema.json",
  "version": "3.7.3",
  "createdAt": "2025-12-11T16:30:22.307Z",
  "database": "postgres",
  "orm": "drizzle",
  "backend": "hono",
  "runtime": "bun",
  "frontend": [
    "tanstack-router"
  ],
  "addons": [
    "husky",
    "turborepo",
    "ultracite"
  ],
  "examples": [],
  "auth": "better-auth",
  "payments": "none",
  "packageManager": "bun",
  "dbSetup": "supabase",
  "api": "trpc",
  "webDeploy": "none",
  "serverDeploy": "none"
}
</file>

<file path="bunfig.toml">
[install]
linker = "isolated"
</file>

<file path="Dockerfile">
# syntax=docker/dockerfile:1

FROM oven/bun:1.3.1-alpine AS base
WORKDIR /app

# Build the application
FROM base AS builder
COPY package.json bun.lock turbo.json ./
COPY apps/server/package.json ./apps/server/
COPY apps/web/package.json ./apps/web/
COPY packages/api/package.json ./packages/api/
COPY packages/auth/package.json ./packages/auth/
COPY packages/db/package.json ./packages/db/
COPY packages/config/package.json ./packages/config/
RUN bun install --frozen-lockfile
COPY . .
RUN bun run build

# Production image
FROM base AS runner
ENV NODE_ENV=production

# Create non-root user
RUN addgroup --system --gid 1001 nodejs && \
    adduser --system --uid 1001 hono
USER hono

COPY --from=builder --chown=hono:nodejs /app/apps/server/dist ./dist

EXPOSE 3000

CMD ["bun", "run", "dist/index.mjs"]
</file>

<file path="packages/api/.gitignore">
# dependencies (bun install)
node_modules

# output
out
dist
*.tgz

# code coverage
coverage
*.lcov

# logs
logs
_.log
report.[0-9]_.[0-9]_.[0-9]_.[0-9]_.json

# dotenv environment variable files
.env
.env.development.local
.env.test.local
.env.production.local
.env.local

# caches
.eslintcache
.cache
*.tsbuildinfo

# IntelliJ based IDEs
.idea

# Finder (MacOS) folder config
.DS_Store
</file>

<file path="packages/api/src/index.test.ts">
import { TRPCError } from "@trpc/server";
import { describe, expect, it } from "vitest";
import { protectedProcedure, publicProcedure, router, t } from "./index";

describe("tRPC setup", () => {
  describe("router", () => {
    it("creates a router from procedures", () => {
      const testRouter = router({
        hello: publicProcedure.query(() => "Hello, World!"),
      });

      expect(testRouter).toBeDefined();
      expect(testRouter._def.procedures.hello).toBeDefined();
    });
  });

  describe("publicProcedure", () => {
    it("allows access without session", async () => {
      const testRouter = router({
        public: publicProcedure.query(() => "public data"),
      });

      const caller = t.createCallerFactory(testRouter)({ session: null });
      const result = await caller.public();

      expect(result).toBe("public data");
    });
  });

  describe("protectedProcedure", () => {
    it("throws UNAUTHORIZED when no session is provided", async () => {
      const testRouter = router({
        protected: protectedProcedure.query(() => "protected data"),
      });

      const caller = t.createCallerFactory(testRouter)({ session: null });

      await expect(caller.protected()).rejects.toThrow(TRPCError);
      await expect(caller.protected()).rejects.toMatchObject({
        code: "UNAUTHORIZED",
      });
    });

    it("allows access with valid session", async () => {
      const testRouter = router({
        protected: protectedProcedure.query(() => "protected data"),
      });

      const mockSession = {
        user: { id: "user-123", email: "test@example.com" },
        session: { id: "session-123" },
      };

      const caller = t.createCallerFactory(testRouter)({
        session: mockSession,
      });
      const result = await caller.protected();

      expect(result).toBe("protected data");
    });

    it("passes session to context after middleware", async () => {
      const testRouter = router({
        getUser: protectedProcedure.query(({ ctx }) => ctx.session.user.id),
      });

      const mockSession = {
        user: { id: "user-456", email: "test@example.com" },
        session: { id: "session-456" },
      };

      const caller = t.createCallerFactory(testRouter)({
        session: mockSession,
      });
      const result = await caller.getUser();

      expect(result).toBe("user-456");
    });
  });
});
</file>

<file path="packages/api/src/streaming.ts">
import {
  and,
  chat,
  chatMessage,
  count,
  DOCUMENTS_BUCKET,
  db,
  eq,
  file,
  supabaseAdmin,
} from "@xquery/db";
import { getOrCreateAssistant, openai } from "./lib/openai";

type StreamQuestionInput = {
  userId: string;
  chatId: string;
  question: string;
};

type StreamEvent =
  | { type: "status"; data: { message: string } }
  | { type: "delta"; data: { content: string } }
  | {
      type: "done";
      data: { userMessageId: string; assistantMessageId: string };
    }
  | { type: "error"; data: { message: string } };

// biome-ignore lint/complexity/noExcessiveCognitiveComplexity: streaming logic requires multiple conditional branches
export async function* streamQuestion(
  input: StreamQuestionInput
): AsyncGenerator<StreamEvent> {
  const { userId, chatId, question } = input;

  const chatResult = await db
    .select({
      id: chat.id,
      fileId: chat.fileId,
      openaiThreadId: chat.openaiThreadId,
      title: chat.title,
    })
    .from(chat)
    .where(and(eq(chat.id, chatId), eq(chat.userId, userId)))
    .limit(1);

  const chatRecord = chatResult[0];
  if (!chatRecord) {
    yield { type: "error", data: { message: "Chat not found" } };
    return;
  }

  const fileResult = await db
    .select()
    .from(file)
    .where(eq(file.id, chatRecord.fileId))
    .limit(1);

  const fileRecord = fileResult[0];
  if (!fileRecord) {
    yield { type: "error", data: { message: "File not found" } };
    return;
  }

  let openaiFileId = fileRecord.openaiFileId;

  if (!openaiFileId) {
    yield { type: "status", data: { message: "Uploading file to AI..." } };

    const { data: fileData, error: downloadError } = await supabaseAdmin.storage
      .from(DOCUMENTS_BUCKET)
      .download(fileRecord.storagePath);

    if (downloadError || !fileData) {
      yield {
        type: "error",
        data: { message: "Failed to download file from storage" },
      };
      return;
    }

    const openaiFile = await openai.files.create({
      file: new File([fileData], fileRecord.originalFilename, {
        type: fileRecord.mimeType,
      }),
      purpose: "assistants",
    });

    openaiFileId = openaiFile.id;

    await db
      .update(file)
      .set({ openaiFileId })
      .where(eq(file.id, chatRecord.fileId));
  }

  const userMessageId = crypto.randomUUID();
  await db.insert(chatMessage).values({
    id: userMessageId,
    chatId,
    role: "user",
    content: question,
  });

  const isFirstMessage = !chatRecord.title;
  if (isFirstMessage) {
    const title =
      question.length > 30 ? `${question.substring(0, 30)}...` : question;
    await db.update(chat).set({ title }).where(eq(chat.id, chatId));
  }

  yield { type: "status", data: { message: "Searching document..." } };

  const assistantId = await getOrCreateAssistant();

  const messageCount = await db
    .select({ count: count() })
    .from(chatMessage)
    .where(eq(chatMessage.chatId, chatId));

  const isFirstChatMessage = (messageCount[0]?.count ?? 0) <= 1;

  if (isFirstChatMessage) {
    await openai.beta.threads.messages.create(chatRecord.openaiThreadId, {
      role: "user",
      content: question,
      attachments: [
        {
          file_id: openaiFileId,
          tools: [{ type: "file_search" }],
        },
      ],
    });
  } else {
    await openai.beta.threads.messages.create(chatRecord.openaiThreadId, {
      role: "user",
      content: question,
    });
  }

  let fullContent = "";

  try {
    const stream = openai.beta.threads.runs.stream(chatRecord.openaiThreadId, {
      assistant_id: assistantId,
    });

    for await (const event of stream) {
      if (event.event === "thread.message.delta") {
        const delta = event.data.delta;
        if (delta.content) {
          for (const block of delta.content) {
            if (block.type === "text" && block.text?.value) {
              fullContent += block.text.value;
              yield { type: "delta", data: { content: block.text.value } };
            }
          }
        }
      } else if (event.event === "thread.run.failed") {
        const error = event.data.last_error;
        yield {
          type: "error",
          data: { message: error?.message || "Assistant run failed" },
        };
        return;
      }
    }
  } catch (streamError) {
    yield {
      type: "error",
      data: {
        message:
          streamError instanceof Error
            ? streamError.message
            : "Stream failed unexpectedly",
      },
    };
    return;
  }

  if (!fullContent) {
    yield {
      type: "error",
      data: { message: "No response received from assistant" },
    };
    return;
  }

  const assistantMessageId = crypto.randomUUID();
  await db.insert(chatMessage).values({
    id: assistantMessageId,
    chatId,
    role: "assistant",
    content: fullContent,
  });

  yield {
    type: "done",
    data: { userMessageId, assistantMessageId },
  };
}
</file>

<file path="packages/api/vitest.config.ts">
import { defineConfig } from "vitest/config";

export default defineConfig({
  test: {
    globals: true,
    environment: "node",
    include: ["src/**/*.{test,spec}.ts"],
    coverage: {
      provider: "v8",
      reporter: ["text", "json", "html"],
      include: ["src/**/*.ts"],
      exclude: ["src/**/*.test.ts", "src/**/*.spec.ts", "**/*.d.ts"],
    },
  },
});
</file>

<file path="packages/auth/.gitignore">
# dependencies (bun install)
node_modules

# output
out
dist
*.tgz

# code coverage
coverage
*.lcov

# logs
logs
_.log
report.[0-9]_.[0-9]_.[0-9]_.[0-9]_.json

# dotenv environment variable files
.env
.env.development.local
.env.test.local
.env.production.local
.env.local

# caches
.eslintcache
.cache
*.tsbuildinfo

# IntelliJ based IDEs
.idea

# Finder (MacOS) folder config
.DS_Store
</file>

<file path="packages/auth/package.json">
{
  "name": "@xquery/auth",
  "exports": {
    ".": {
      "default": "./src/index.ts"
    },
    "./*": {
      "default": "./src/*.ts"
    }
  },
  "type": "module",
  "scripts": {},
  "devDependencies": {
    "@xquery/config": "workspace:*"
  },
  "peerDependencies": {
    "typescript": "^5"
  },
  "dependencies": {
    "better-auth": "catalog:",
    "dotenv": "catalog:",
    "zod": "catalog:",
    "@xquery/db": "workspace:*"
  }
}
</file>

<file path="packages/db/.gitignore">
# dependencies (bun install)
node_modules

# output
out
dist
*.tgz
/prisma/generated

# code coverage
coverage
*.lcov

# logs
logs
_.log
report.[0-9]_.[0-9]_.[0-9]_.[0-9]_.json

# dotenv environment variable files
.env
.env.development.local
.env.test.local
.env.production.local
.env.local

# caches
.eslintcache
.cache
*.tsbuildinfo

# IntelliJ based IDEs
.idea

# Finder (MacOS) folder config
.DS_Store
</file>

<file path="packages/db/src/migrations/0000_giant_komodo.sql">
CREATE TABLE "account" (
	"id" text PRIMARY KEY NOT NULL,
	"account_id" text NOT NULL,
	"provider_id" text NOT NULL,
	"user_id" text NOT NULL,
	"access_token" text,
	"refresh_token" text,
	"id_token" text,
	"access_token_expires_at" timestamp,
	"refresh_token_expires_at" timestamp,
	"scope" text,
	"password" text,
	"created_at" timestamp DEFAULT now() NOT NULL,
	"updated_at" timestamp NOT NULL
);
--> statement-breakpoint
CREATE TABLE "session" (
	"id" text PRIMARY KEY NOT NULL,
	"expires_at" timestamp NOT NULL,
	"token" text NOT NULL,
	"created_at" timestamp DEFAULT now() NOT NULL,
	"updated_at" timestamp NOT NULL,
	"ip_address" text,
	"user_agent" text,
	"user_id" text NOT NULL,
	CONSTRAINT "session_token_unique" UNIQUE("token")
);
--> statement-breakpoint
CREATE TABLE "user" (
	"id" text PRIMARY KEY NOT NULL,
	"name" text NOT NULL,
	"email" text NOT NULL,
	"email_verified" boolean DEFAULT false NOT NULL,
	"image" text,
	"created_at" timestamp DEFAULT now() NOT NULL,
	"updated_at" timestamp DEFAULT now() NOT NULL,
	CONSTRAINT "user_email_unique" UNIQUE("email")
);
--> statement-breakpoint
CREATE TABLE "verification" (
	"id" text PRIMARY KEY NOT NULL,
	"identifier" text NOT NULL,
	"value" text NOT NULL,
	"expires_at" timestamp NOT NULL,
	"created_at" timestamp DEFAULT now() NOT NULL,
	"updated_at" timestamp DEFAULT now() NOT NULL
);
--> statement-breakpoint
ALTER TABLE "account" ADD CONSTRAINT "account_user_id_user_id_fk" FOREIGN KEY ("user_id") REFERENCES "public"."user"("id") ON DELETE cascade ON UPDATE no action;--> statement-breakpoint
ALTER TABLE "session" ADD CONSTRAINT "session_user_id_user_id_fk" FOREIGN KEY ("user_id") REFERENCES "public"."user"("id") ON DELETE cascade ON UPDATE no action;--> statement-breakpoint
CREATE INDEX "account_userId_idx" ON "account" USING btree ("user_id");--> statement-breakpoint
CREATE INDEX "session_userId_idx" ON "session" USING btree ("user_id");--> statement-breakpoint
CREATE INDEX "verification_identifier_idx" ON "verification" USING btree ("identifier");
</file>

<file path="packages/db/src/migrations/0001_violet_wildside.sql">
CREATE TABLE "file" (
	"id" text PRIMARY KEY NOT NULL,
	"user_id" text NOT NULL,
	"name" text NOT NULL,
	"original_filename" text NOT NULL,
	"mime_type" text NOT NULL,
	"size" integer NOT NULL,
	"storage_path" text NOT NULL,
	"openai_file_id" text,
	"created_at" timestamp DEFAULT now() NOT NULL,
	"updated_at" timestamp DEFAULT now() NOT NULL,
	CONSTRAINT "file_storage_path_unique" UNIQUE("storage_path")
);
--> statement-breakpoint
ALTER TABLE "file" ADD CONSTRAINT "file_user_id_user_id_fk" FOREIGN KEY ("user_id") REFERENCES "public"."user"("id") ON DELETE cascade ON UPDATE no action;--> statement-breakpoint
CREATE INDEX "file_userId_idx" ON "file" USING btree ("user_id");--> statement-breakpoint
CREATE INDEX "file_createdAt_idx" ON "file" USING btree ("created_at");
</file>

<file path="packages/db/src/migrations/meta/0001_snapshot.json">
{
  "id": "87448214-1662-4bab-b425-cbb40d2640eb",
  "prevId": "13252420-bfe8-4878-b599-bdb983076fe9",
  "version": "7",
  "dialect": "postgresql",
  "tables": {
    "public.account": {
      "name": "account",
      "schema": "",
      "columns": {
        "id": {
          "name": "id",
          "type": "text",
          "primaryKey": true,
          "notNull": true
        },
        "account_id": {
          "name": "account_id",
          "type": "text",
          "primaryKey": false,
          "notNull": true
        },
        "provider_id": {
          "name": "provider_id",
          "type": "text",
          "primaryKey": false,
          "notNull": true
        },
        "user_id": {
          "name": "user_id",
          "type": "text",
          "primaryKey": false,
          "notNull": true
        },
        "access_token": {
          "name": "access_token",
          "type": "text",
          "primaryKey": false,
          "notNull": false
        },
        "refresh_token": {
          "name": "refresh_token",
          "type": "text",
          "primaryKey": false,
          "notNull": false
        },
        "id_token": {
          "name": "id_token",
          "type": "text",
          "primaryKey": false,
          "notNull": false
        },
        "access_token_expires_at": {
          "name": "access_token_expires_at",
          "type": "timestamp",
          "primaryKey": false,
          "notNull": false
        },
        "refresh_token_expires_at": {
          "name": "refresh_token_expires_at",
          "type": "timestamp",
          "primaryKey": false,
          "notNull": false
        },
        "scope": {
          "name": "scope",
          "type": "text",
          "primaryKey": false,
          "notNull": false
        },
        "password": {
          "name": "password",
          "type": "text",
          "primaryKey": false,
          "notNull": false
        },
        "created_at": {
          "name": "created_at",
          "type": "timestamp",
          "primaryKey": false,
          "notNull": true,
          "default": "now()"
        },
        "updated_at": {
          "name": "updated_at",
          "type": "timestamp",
          "primaryKey": false,
          "notNull": true
        }
      },
      "indexes": {
        "account_userId_idx": {
          "name": "account_userId_idx",
          "columns": [
            {
              "expression": "user_id",
              "isExpression": false,
              "asc": true,
              "nulls": "last"
            }
          ],
          "isUnique": false,
          "concurrently": false,
          "method": "btree",
          "with": {}
        }
      },
      "foreignKeys": {
        "account_user_id_user_id_fk": {
          "name": "account_user_id_user_id_fk",
          "tableFrom": "account",
          "tableTo": "user",
          "columnsFrom": ["user_id"],
          "columnsTo": ["id"],
          "onDelete": "cascade",
          "onUpdate": "no action"
        }
      },
      "compositePrimaryKeys": {},
      "uniqueConstraints": {},
      "policies": {},
      "checkConstraints": {},
      "isRLSEnabled": false
    },
    "public.session": {
      "name": "session",
      "schema": "",
      "columns": {
        "id": {
          "name": "id",
          "type": "text",
          "primaryKey": true,
          "notNull": true
        },
        "expires_at": {
          "name": "expires_at",
          "type": "timestamp",
          "primaryKey": false,
          "notNull": true
        },
        "token": {
          "name": "token",
          "type": "text",
          "primaryKey": false,
          "notNull": true
        },
        "created_at": {
          "name": "created_at",
          "type": "timestamp",
          "primaryKey": false,
          "notNull": true,
          "default": "now()"
        },
        "updated_at": {
          "name": "updated_at",
          "type": "timestamp",
          "primaryKey": false,
          "notNull": true
        },
        "ip_address": {
          "name": "ip_address",
          "type": "text",
          "primaryKey": false,
          "notNull": false
        },
        "user_agent": {
          "name": "user_agent",
          "type": "text",
          "primaryKey": false,
          "notNull": false
        },
        "user_id": {
          "name": "user_id",
          "type": "text",
          "primaryKey": false,
          "notNull": true
        }
      },
      "indexes": {
        "session_userId_idx": {
          "name": "session_userId_idx",
          "columns": [
            {
              "expression": "user_id",
              "isExpression": false,
              "asc": true,
              "nulls": "last"
            }
          ],
          "isUnique": false,
          "concurrently": false,
          "method": "btree",
          "with": {}
        }
      },
      "foreignKeys": {
        "session_user_id_user_id_fk": {
          "name": "session_user_id_user_id_fk",
          "tableFrom": "session",
          "tableTo": "user",
          "columnsFrom": ["user_id"],
          "columnsTo": ["id"],
          "onDelete": "cascade",
          "onUpdate": "no action"
        }
      },
      "compositePrimaryKeys": {},
      "uniqueConstraints": {
        "session_token_unique": {
          "name": "session_token_unique",
          "nullsNotDistinct": false,
          "columns": ["token"]
        }
      },
      "policies": {},
      "checkConstraints": {},
      "isRLSEnabled": false
    },
    "public.user": {
      "name": "user",
      "schema": "",
      "columns": {
        "id": {
          "name": "id",
          "type": "text",
          "primaryKey": true,
          "notNull": true
        },
        "name": {
          "name": "name",
          "type": "text",
          "primaryKey": false,
          "notNull": true
        },
        "email": {
          "name": "email",
          "type": "text",
          "primaryKey": false,
          "notNull": true
        },
        "email_verified": {
          "name": "email_verified",
          "type": "boolean",
          "primaryKey": false,
          "notNull": true,
          "default": false
        },
        "image": {
          "name": "image",
          "type": "text",
          "primaryKey": false,
          "notNull": false
        },
        "created_at": {
          "name": "created_at",
          "type": "timestamp",
          "primaryKey": false,
          "notNull": true,
          "default": "now()"
        },
        "updated_at": {
          "name": "updated_at",
          "type": "timestamp",
          "primaryKey": false,
          "notNull": true,
          "default": "now()"
        }
      },
      "indexes": {},
      "foreignKeys": {},
      "compositePrimaryKeys": {},
      "uniqueConstraints": {
        "user_email_unique": {
          "name": "user_email_unique",
          "nullsNotDistinct": false,
          "columns": ["email"]
        }
      },
      "policies": {},
      "checkConstraints": {},
      "isRLSEnabled": false
    },
    "public.verification": {
      "name": "verification",
      "schema": "",
      "columns": {
        "id": {
          "name": "id",
          "type": "text",
          "primaryKey": true,
          "notNull": true
        },
        "identifier": {
          "name": "identifier",
          "type": "text",
          "primaryKey": false,
          "notNull": true
        },
        "value": {
          "name": "value",
          "type": "text",
          "primaryKey": false,
          "notNull": true
        },
        "expires_at": {
          "name": "expires_at",
          "type": "timestamp",
          "primaryKey": false,
          "notNull": true
        },
        "created_at": {
          "name": "created_at",
          "type": "timestamp",
          "primaryKey": false,
          "notNull": true,
          "default": "now()"
        },
        "updated_at": {
          "name": "updated_at",
          "type": "timestamp",
          "primaryKey": false,
          "notNull": true,
          "default": "now()"
        }
      },
      "indexes": {
        "verification_identifier_idx": {
          "name": "verification_identifier_idx",
          "columns": [
            {
              "expression": "identifier",
              "isExpression": false,
              "asc": true,
              "nulls": "last"
            }
          ],
          "isUnique": false,
          "concurrently": false,
          "method": "btree",
          "with": {}
        }
      },
      "foreignKeys": {},
      "compositePrimaryKeys": {},
      "uniqueConstraints": {},
      "policies": {},
      "checkConstraints": {},
      "isRLSEnabled": false
    },
    "public.file": {
      "name": "file",
      "schema": "",
      "columns": {
        "id": {
          "name": "id",
          "type": "text",
          "primaryKey": true,
          "notNull": true
        },
        "user_id": {
          "name": "user_id",
          "type": "text",
          "primaryKey": false,
          "notNull": true
        },
        "name": {
          "name": "name",
          "type": "text",
          "primaryKey": false,
          "notNull": true
        },
        "original_filename": {
          "name": "original_filename",
          "type": "text",
          "primaryKey": false,
          "notNull": true
        },
        "mime_type": {
          "name": "mime_type",
          "type": "text",
          "primaryKey": false,
          "notNull": true
        },
        "size": {
          "name": "size",
          "type": "integer",
          "primaryKey": false,
          "notNull": true
        },
        "storage_path": {
          "name": "storage_path",
          "type": "text",
          "primaryKey": false,
          "notNull": true
        },
        "openai_file_id": {
          "name": "openai_file_id",
          "type": "text",
          "primaryKey": false,
          "notNull": false
        },
        "created_at": {
          "name": "created_at",
          "type": "timestamp",
          "primaryKey": false,
          "notNull": true,
          "default": "now()"
        },
        "updated_at": {
          "name": "updated_at",
          "type": "timestamp",
          "primaryKey": false,
          "notNull": true,
          "default": "now()"
        }
      },
      "indexes": {
        "file_userId_idx": {
          "name": "file_userId_idx",
          "columns": [
            {
              "expression": "user_id",
              "isExpression": false,
              "asc": true,
              "nulls": "last"
            }
          ],
          "isUnique": false,
          "concurrently": false,
          "method": "btree",
          "with": {}
        },
        "file_createdAt_idx": {
          "name": "file_createdAt_idx",
          "columns": [
            {
              "expression": "created_at",
              "isExpression": false,
              "asc": true,
              "nulls": "last"
            }
          ],
          "isUnique": false,
          "concurrently": false,
          "method": "btree",
          "with": {}
        }
      },
      "foreignKeys": {
        "file_user_id_user_id_fk": {
          "name": "file_user_id_user_id_fk",
          "tableFrom": "file",
          "tableTo": "user",
          "columnsFrom": ["user_id"],
          "columnsTo": ["id"],
          "onDelete": "cascade",
          "onUpdate": "no action"
        }
      },
      "compositePrimaryKeys": {},
      "uniqueConstraints": {
        "file_storage_path_unique": {
          "name": "file_storage_path_unique",
          "nullsNotDistinct": false,
          "columns": ["storage_path"]
        }
      },
      "policies": {},
      "checkConstraints": {},
      "isRLSEnabled": false
    }
  },
  "enums": {},
  "schemas": {},
  "sequences": {},
  "roles": {},
  "policies": {},
  "views": {},
  "_meta": {
    "columns": {},
    "schemas": {},
    "tables": {}
  }
}
</file>

<file path="packages/db/src/schema/chat.ts">
import { relations } from "drizzle-orm";
import { index, pgTable, text, timestamp } from "drizzle-orm/pg-core";
import { user } from "./auth";
import { file } from "./files";

export const chat = pgTable(
  "chat",
  {
    id: text("id").primaryKey(),
    userId: text("user_id")
      .notNull()
      .references(() => user.id, { onDelete: "cascade" }),
    fileId: text("file_id")
      .notNull()
      .references(() => file.id, { onDelete: "cascade" }),

    title: text("title"),
    openaiThreadId: text("openai_thread_id").notNull(),

    createdAt: timestamp("created_at").defaultNow().notNull(),
    updatedAt: timestamp("updated_at")
      .defaultNow()
      .$onUpdate(() => new Date())
      .notNull(),
  },
  (table) => [
    index("chat_userId_idx").on(table.userId),
    index("chat_fileId_idx").on(table.fileId),
    index("chat_createdAt_idx").on(table.createdAt),
  ]
);

export const chatMessage = pgTable(
  "chat_message",
  {
    id: text("id").primaryKey(),
    chatId: text("chat_id")
      .notNull()
      .references(() => chat.id, { onDelete: "cascade" }),

    role: text("role", { enum: ["user", "assistant"] }).notNull(),
    content: text("content").notNull(),

    createdAt: timestamp("created_at").defaultNow().notNull(),
  },
  (table) => [
    index("chatMessage_chatId_idx").on(table.chatId),
    index("chatMessage_createdAt_idx").on(table.createdAt),
  ]
);

export const chatRelations = relations(chat, ({ one, many }) => ({
  user: one(user, {
    fields: [chat.userId],
    references: [user.id],
  }),
  file: one(file, {
    fields: [chat.fileId],
    references: [file.id],
  }),
  messages: many(chatMessage),
}));

export const chatMessageRelations = relations(chatMessage, ({ one }) => ({
  chat: one(chat, {
    fields: [chatMessage.chatId],
    references: [chat.id],
  }),
}));
</file>

<file path="packages/db/src/schema/files.ts">
import { relations } from "drizzle-orm";
import { index, integer, pgTable, text, timestamp } from "drizzle-orm/pg-core";
import { user } from "./auth";

export const file = pgTable(
  "file",
  {
    id: text("id").primaryKey(),
    userId: text("user_id")
      .notNull()
      .references(() => user.id, { onDelete: "cascade" }),

    // User-facing metadata
    name: text("name").notNull(),
    originalFilename: text("original_filename").notNull(),

    // Technical metadata
    mimeType: text("mime_type").notNull(),
    size: integer("size").notNull(),
    storagePath: text("storage_path").notNull().unique(),

    // OpenAI integration (for future Assistants API)
    openaiFileId: text("openai_file_id"),

    // Timestamps
    createdAt: timestamp("created_at").defaultNow().notNull(),
    updatedAt: timestamp("updated_at")
      .defaultNow()
      .$onUpdate(() => new Date())
      .notNull(),
  },
  (table) => [
    index("file_userId_idx").on(table.userId),
    index("file_createdAt_idx").on(table.createdAt),
  ]
);

export const fileRelations = relations(file, ({ one }) => ({
  user: one(user, {
    fields: [file.userId],
    references: [user.id],
  }),
}));
</file>

<file path="packages/db/src/supabase.ts">
import { createClient } from "@supabase/supabase-js";

const supabaseUrl = process.env.SUPABASE_URL || "http://127.0.0.1:54321";
const supabaseServiceKey = process.env.SUPABASE_SERVICE_KEY || "";

export const supabaseAdmin = createClient(supabaseUrl, supabaseServiceKey, {
  auth: {
    autoRefreshToken: false,
    persistSession: false,
  },
});

export const DOCUMENTS_BUCKET = "documents";

export const ALLOWED_MIME_TYPES = [
  "application/pdf",
  "application/vnd.openxmlformats-officedocument.wordprocessingml.document",
  "text/plain",
  "text/markdown",
] as const;

export const MAX_FILE_SIZE = 10 * 1024 * 1024; // 10 MB

export type AllowedMimeType = (typeof ALLOWED_MIME_TYPES)[number];

export async function ensureDocumentsBucketExists() {
  const { data: buckets } = await supabaseAdmin.storage.listBuckets();

  const bucketExists = buckets?.some(
    (bucket) => bucket.name === DOCUMENTS_BUCKET
  );

  if (!bucketExists) {
    const { error } = await supabaseAdmin.storage.createBucket(
      DOCUMENTS_BUCKET,
      {
        public: false,
        fileSizeLimit: MAX_FILE_SIZE,
        allowedMimeTypes: [...ALLOWED_MIME_TYPES],
      }
    );

    if (error) {
      console.error("Failed to create documents bucket:", error);
      throw error;
    }

    console.log("Created documents storage bucket");
  }
}
</file>

<file path="packages/db/supabase/.branches/_current_branch">
main
</file>

<file path="packages/db/supabase/.temp/cli-latest">
v2.65.5
</file>

<file path="supabase/.branches/_current_branch">
main
</file>

<file path="supabase/.temp/cli-latest">
v2.65.5
</file>

<file path=".husky/pre-commit">
#!/bin/sh
# Exit on any error
set -e

# Check if there are any staged files
if [ -z "$(git diff --cached --name-only)" ]; then
  echo "No staged files to format"
  exit 0
fi

# Store the hash of staged changes to detect modifications
STAGED_HASH=$(git diff --cached | sha256sum | cut -d' ' -f1)

# Save list of staged files (handling all file states)
STAGED_FILES=$(git diff --cached --name-only --diff-filter=ACMR)
PARTIALLY_STAGED=$(git diff --name-only)

# Stash unstaged changes to preserve working directory
# --keep-index keeps staged changes in working tree
git stash push --quiet --keep-index --message "pre-commit-stash" || true
STASHED=$?

# Run formatter on the staged files
bun x ultracite fix
FORMAT_EXIT_CODE=$?

# Restore working directory state
if [ $STASHED -eq 0 ]; then
  # Re-stage the formatted files
  if [ -n "$STAGED_FILES" ]; then
    echo "$STAGED_FILES" | while IFS= read -r file; do
      if [ -f "$file" ]; then
        git add "$file"
      fi
    done
  fi
  
  # Restore unstaged changes
  git stash pop --quiet || true
  
  # Restore partial staging if files were partially staged
  if [ -n "$PARTIALLY_STAGED" ]; then
    for file in $PARTIALLY_STAGED; do
      if [ -f "$file" ] && echo "$STAGED_FILES" | grep -q "^$file$"; then
        # File was partially staged - need to unstage the unstaged parts
        git restore --staged "$file" 2>/dev/null || true
        git add -p "$file" < /dev/null 2>/dev/null || git add "$file"
      fi
    done
  fi
else
  # No stash was created, just re-add the formatted files
  if [ -n "$STAGED_FILES" ]; then
    echo "$STAGED_FILES" | while IFS= read -r file; do
      if [ -f "$file" ]; then
        git add "$file"
      fi
    done
  fi
fi

# Check if staged files actually changed
NEW_STAGED_HASH=$(git diff --cached | sha256sum | cut -d' ' -f1)
if [ "$STAGED_HASH" != "$NEW_STAGED_HASH" ]; then
  echo " Files formatted by Ultracite"
fi

exit $FORMAT_EXIT_CODE
</file>

<file path="apps/server/.env.example">
BETTER_AUTH_SECRET=
BETTER_AUTH_URL=
CORS_ORIGIN=
INVITATION_CODE=
DATABASE_URL=
SUPABASE_URL=
SUPABASE_SERVICE_KEY=
OPENAI_API_KEY=
</file>

<file path="apps/server/tsconfig.json">
{
  "extends": "@xquery/config/tsconfig.base.json",
  "compilerOptions": {
    "composite": true,
    "outDir": "dist",
    "baseUrl": ".",
    "paths": {
      "@/*": ["./src/*"]
    },
    "jsx": "react-jsx",
    "jsxImportSource": "hono/jsx",
    "strictNullChecks": true
  }
}
</file>

<file path="apps/web/components.json">
{
  "$schema": "https://ui.shadcn.com/schema.json",
  "style": "new-york",
  "rsc": false,
  "tsx": true,
  "tailwind": {
    "config": "",
    "css": "src/index.css",
    "baseColor": "neutral",
    "cssVariables": true,
    "prefix": ""
  },
  "aliases": {
    "components": "@/components",
    "utils": "@/lib/utils",
    "ui": "@/components/ui",
    "lib": "@/lib",
    "hooks": "@/hooks"
  },
  "iconLibrary": "lucide"
}
</file>

<file path="apps/web/src/components/keyboard-shortcuts-dialog.tsx">
import { Keyboard } from "lucide-react";
import { createContext, useContext, useEffect, useMemo, useState } from "react";
import {
  Dialog,
  DialogContent,
  DialogHeader,
  DialogTitle,
} from "@/components/ui/dialog";
import { useHotkeys } from "@/hooks/use-hotkeys";

type Shortcut = {
  keys: string[];
  description: string;
  context?: string;
};

const shortcuts: Shortcut[] = [
  { keys: ["Ctrl", "Enter"], description: "Send message", context: "Chat" },
  { keys: ["Escape"], description: "Cancel streaming", context: "Chat" },
  {
    keys: ["Ctrl", "Shift", "J"],
    description: "New chat",
    context: "Chat",
  },
  {
    keys: ["Ctrl", "Shift", "F"],
    description: "Focus search",
    context: "Chat",
  },
  {
    keys: ["Ctrl", "Shift", "U"],
    description: "Upload file",
    context: "Files",
  },
  { keys: ["Ctrl", "Shift", "?"], description: "Show keyboard shortcuts" },
];

function Kbd({ children }: { children: React.ReactNode }) {
  return (
    <kbd className="inline-flex h-5 min-w-5 items-center justify-center rounded border border-border bg-muted px-1.5 font-medium font-mono text-muted-foreground text-xs">
      {children}
    </kbd>
  );
}

type KeyboardShortcutsContextType = {
  open: boolean;
  setOpen: (open: boolean) => void;
};

const KeyboardShortcutsContext =
  createContext<KeyboardShortcutsContextType | null>(null);

function useKeyboardShortcutsContext() {
  const context = useContext(KeyboardShortcutsContext);
  if (!context) {
    throw new Error(
      "KeyboardShortcuts components must be used within KeyboardShortcutsDialog"
    );
  }
  return context;
}

export function KeyboardShortcutsTrigger() {
  const { setOpen } = useKeyboardShortcutsContext();

  return (
    <button
      className="flex w-full items-center gap-2 rounded-md px-2 py-1.5 text-muted-foreground text-xs transition-colors hover:text-foreground"
      onClick={() => setOpen(true)}
      type="button"
    >
      <Keyboard className="h-3.5 w-3.5" />
      Keyboard shortcuts
    </button>
  );
}

export function KeyboardShortcutsDialog({
  children,
}: {
  children?: React.ReactNode;
}) {
  const [open, setOpen] = useState(false);

  const hotkeys = useMemo(
    () => [
      {
        key: "?",
        ctrl: true,
        shift: true,
        callback: () => setOpen((prev) => !prev),
      },
    ],
    []
  );

  useHotkeys(hotkeys);

  useEffect(() => {
    function handleKeyDown(event: KeyboardEvent) {
      if (event.key === "Escape" && open) {
        setOpen(false);
      }
    }
    document.addEventListener("keydown", handleKeyDown);
    return () => document.removeEventListener("keydown", handleKeyDown);
  }, [open]);

  const contextValue = useMemo(() => ({ open, setOpen }), [open]);

  return (
    <KeyboardShortcutsContext.Provider value={contextValue}>
      {children}
      <Dialog onOpenChange={setOpen} open={open}>
        <DialogContent className="sm:max-w-md">
          <DialogHeader>
            <DialogTitle>Keyboard Shortcuts</DialogTitle>
          </DialogHeader>
          <div className="space-y-3">
            {shortcuts.map((shortcut) => (
              <div
                className="flex items-center justify-between gap-4"
                key={shortcut.description}
              >
                <div className="flex items-center gap-2">
                  <span className="text-sm">{shortcut.description}</span>
                  {shortcut.context && (
                    <span className="rounded bg-muted px-1.5 py-0.5 text-muted-foreground text-xs">
                      {shortcut.context}
                    </span>
                  )}
                </div>
                <div className="flex shrink-0 items-center gap-1">
                  {shortcut.keys.map((key, index) => (
                    <span className="flex items-center gap-1" key={key}>
                      {index > 0 && (
                        <span className="text-muted-foreground text-xs">+</span>
                      )}
                      <Kbd>{key}</Kbd>
                    </span>
                  ))}
                </div>
              </div>
            ))}
          </div>
        </DialogContent>
      </Dialog>
    </KeyboardShortcutsContext.Provider>
  );
}
</file>

<file path="apps/web/src/components/loader.tsx">
import { Loader2 } from "lucide-react";

export default function Loader() {
  return (
    <div className="flex h-full items-center justify-center pt-8">
      <Loader2 className="animate-spin" />
    </div>
  );
}
</file>

<file path="apps/web/src/components/mode-toggle.tsx">
import { Moon, Sun } from "lucide-react";
import { useTheme } from "@/components/theme-provider";
import { Button } from "@/components/ui/button";
import {
  DropdownMenu,
  DropdownMenuContent,
  DropdownMenuItem,
  DropdownMenuTrigger,
} from "@/components/ui/dropdown-menu";

export function ModeToggle() {
  const { setTheme } = useTheme();

  return (
    <DropdownMenu>
      <DropdownMenuTrigger asChild>
        <Button size="icon" variant="outline">
          <Sun className="dark:-rotate-90 h-[1.2rem] w-[1.2rem] rotate-0 scale-100 transition-all dark:scale-0" />
          <Moon className="absolute h-[1.2rem] w-[1.2rem] rotate-90 scale-0 transition-all dark:rotate-0 dark:scale-100" />
          <span className="sr-only">Toggle theme</span>
        </Button>
      </DropdownMenuTrigger>
      <DropdownMenuContent align="end">
        <DropdownMenuItem onClick={() => setTheme("light")}>
          Light
        </DropdownMenuItem>
        <DropdownMenuItem onClick={() => setTheme("dark")}>
          Dark
        </DropdownMenuItem>
        <DropdownMenuItem onClick={() => setTheme("system")}>
          System
        </DropdownMenuItem>
      </DropdownMenuContent>
    </DropdownMenu>
  );
}
</file>

<file path="apps/web/src/components/theme-provider.tsx">
import { ThemeProvider as NextThemesProvider } from "next-themes";
import type * as React from "react";

export function ThemeProvider({
  children,
  ...props
}: React.ComponentProps<typeof NextThemesProvider>) {
  return <NextThemesProvider {...props}>{children}</NextThemesProvider>;
}

export { useTheme } from "next-themes";
</file>

<file path="apps/web/src/components/ui/button.tsx">
import { cva, type VariantProps } from "class-variance-authority";
import { Slot as SlotPrimitive } from "radix-ui";
import type * as React from "react";

import { cn } from "@/lib/utils";

const buttonVariants = cva(
  "inline-flex shrink-0 items-center justify-center gap-2 whitespace-nowrap rounded-md font-medium text-sm outline-none transition-all focus-visible:border-ring focus-visible:ring-[3px] focus-visible:ring-ring/50 disabled:pointer-events-none disabled:opacity-50 aria-invalid:border-destructive aria-invalid:ring-destructive/20 dark:aria-invalid:ring-destructive/40 [&_svg:not([class*='size-'])]:size-4 [&_svg]:pointer-events-none [&_svg]:shrink-0",
  {
    variants: {
      variant: {
        default:
          "bg-primary text-primary-foreground shadow-xs hover:bg-primary/90",
        destructive:
          "bg-destructive text-white shadow-xs hover:bg-destructive/90 focus-visible:ring-destructive/20 dark:bg-destructive/60 dark:focus-visible:ring-destructive/40",
        outline:
          "border bg-background shadow-xs hover:bg-accent hover:text-accent-foreground dark:border-input dark:bg-input/30 dark:hover:bg-input/50",
        secondary:
          "bg-secondary text-secondary-foreground shadow-xs hover:bg-secondary/80",
        ghost:
          "hover:bg-accent hover:text-accent-foreground dark:hover:bg-accent/50",
        link: "text-primary underline-offset-4 hover:underline",
      },
      size: {
        default: "h-9 px-4 py-2 has-[>svg]:px-3",
        sm: "h-8 gap-1.5 rounded-md px-3 has-[>svg]:px-2.5",
        lg: "h-10 rounded-md px-6 has-[>svg]:px-4",
        icon: "size-9",
      },
    },
    defaultVariants: {
      variant: "default",
      size: "default",
    },
  }
);

function Button({
  className,
  variant,
  size,
  asChild = false,
  ...props
}: React.ComponentProps<"button"> &
  VariantProps<typeof buttonVariants> & {
    asChild?: boolean;
  }) {
  const Comp = asChild ? SlotPrimitive.Slot : "button";

  return (
    <Comp
      className={cn(buttonVariants({ variant, size, className }))}
      data-slot="button"
      {...props}
    />
  );
}

export { Button, buttonVariants };
</file>

<file path="apps/web/src/components/ui/card.tsx">
import type * as React from "react";

import { cn } from "@/lib/utils";

function Card({ className, ...props }: React.ComponentProps<"div">) {
  return (
    <div
      className={cn(
        "flex flex-col gap-6 rounded-xl border bg-card py-6 text-card-foreground shadow-sm",
        className
      )}
      data-slot="card"
      {...props}
    />
  );
}

function CardHeader({ className, ...props }: React.ComponentProps<"div">) {
  return (
    <div
      className={cn(
        "@container/card-header grid auto-rows-min grid-rows-[auto_auto] items-start gap-1.5 px-6 has-data-[slot=card-action]:grid-cols-[1fr_auto] [.border-b]:pb-6",
        className
      )}
      data-slot="card-header"
      {...props}
    />
  );
}

function CardTitle({ className, ...props }: React.ComponentProps<"div">) {
  return (
    <div
      className={cn("font-semibold leading-none", className)}
      data-slot="card-title"
      {...props}
    />
  );
}

function CardDescription({ className, ...props }: React.ComponentProps<"div">) {
  return (
    <div
      className={cn("text-muted-foreground text-sm", className)}
      data-slot="card-description"
      {...props}
    />
  );
}

function CardAction({ className, ...props }: React.ComponentProps<"div">) {
  return (
    <div
      className={cn(
        "col-start-2 row-span-2 row-start-1 self-start justify-self-end",
        className
      )}
      data-slot="card-action"
      {...props}
    />
  );
}

function CardContent({ className, ...props }: React.ComponentProps<"div">) {
  return (
    <div
      className={cn("px-6", className)}
      data-slot="card-content"
      {...props}
    />
  );
}

function CardFooter({ className, ...props }: React.ComponentProps<"div">) {
  return (
    <div
      className={cn("flex items-center px-6 [.border-t]:pt-6", className)}
      data-slot="card-footer"
      {...props}
    />
  );
}

export {
  Card,
  CardHeader,
  CardFooter,
  CardTitle,
  CardAction,
  CardDescription,
  CardContent,
};
</file>

<file path="apps/web/src/components/ui/checkbox.tsx">
import { CheckIcon } from "lucide-react";
import { Checkbox as CheckboxPrimitive } from "radix-ui";
import type * as React from "react";

import { cn } from "@/lib/utils";

function Checkbox({
  className,
  ...props
}: React.ComponentProps<typeof CheckboxPrimitive.Root>) {
  return (
    <CheckboxPrimitive.Root
      className={cn(
        "peer size-4 shrink-0 rounded-[4px] border border-input shadow-xs outline-none transition-shadow focus-visible:border-ring focus-visible:ring-[3px] focus-visible:ring-ring/50 disabled:cursor-not-allowed disabled:opacity-50 aria-invalid:border-destructive aria-invalid:ring-destructive/20 data-[state=checked]:border-primary data-[state=checked]:bg-primary data-[state=checked]:text-primary-foreground dark:bg-input/30 dark:data-[state=checked]:bg-primary dark:aria-invalid:ring-destructive/40",
        className
      )}
      data-slot="checkbox"
      {...props}
    >
      <CheckboxPrimitive.Indicator
        className="flex items-center justify-center text-current transition-none"
        data-slot="checkbox-indicator"
      >
        <CheckIcon className="size-3.5" />
      </CheckboxPrimitive.Indicator>
    </CheckboxPrimitive.Root>
  );
}

export { Checkbox };
</file>

<file path="apps/web/src/components/ui/dialog.tsx">
import * as DialogPrimitive from "@radix-ui/react-dialog";
import { XIcon } from "lucide-react";
import type * as React from "react";

import { cn } from "@/lib/utils";

function Dialog({
  ...props
}: React.ComponentProps<typeof DialogPrimitive.Root>) {
  return <DialogPrimitive.Root data-slot="dialog" {...props} />;
}

function DialogTrigger({
  ...props
}: React.ComponentProps<typeof DialogPrimitive.Trigger>) {
  return <DialogPrimitive.Trigger data-slot="dialog-trigger" {...props} />;
}

function DialogPortal({
  ...props
}: React.ComponentProps<typeof DialogPrimitive.Portal>) {
  return <DialogPrimitive.Portal data-slot="dialog-portal" {...props} />;
}

function DialogClose({
  ...props
}: React.ComponentProps<typeof DialogPrimitive.Close>) {
  return <DialogPrimitive.Close data-slot="dialog-close" {...props} />;
}

function DialogOverlay({
  className,
  ...props
}: React.ComponentProps<typeof DialogPrimitive.Overlay>) {
  return (
    <DialogPrimitive.Overlay
      className={cn(
        "data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 fixed inset-0 z-50 bg-black/50 data-[state=closed]:animate-out data-[state=open]:animate-in",
        className
      )}
      data-slot="dialog-overlay"
      {...props}
    />
  );
}

function DialogContent({
  className,
  children,
  showCloseButton = true,
  ...props
}: React.ComponentProps<typeof DialogPrimitive.Content> & {
  showCloseButton?: boolean;
}) {
  return (
    <DialogPortal data-slot="dialog-portal">
      <DialogOverlay />
      <DialogPrimitive.Content
        className={cn(
          "data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 fixed top-[50%] left-[50%] z-50 flex w-[calc(100%-2rem)] max-w-lg translate-x-[-50%] translate-y-[-50%] flex-col gap-4 overflow-hidden rounded-lg border bg-background p-6 shadow-lg duration-200 data-[state=closed]:animate-out data-[state=open]:animate-in [&>*]:min-w-0",
          className
        )}
        data-slot="dialog-content"
        {...props}
      >
        {children}
        {showCloseButton && (
          <DialogPrimitive.Close
            className="absolute top-4 right-4 rounded-xs opacity-70 ring-offset-background transition-opacity hover:opacity-100 focus:outline-hidden focus:ring-2 focus:ring-ring focus:ring-offset-2 disabled:pointer-events-none data-[state=open]:bg-accent data-[state=open]:text-muted-foreground [&_svg:not([class*='size-'])]:size-4 [&_svg]:pointer-events-none [&_svg]:shrink-0"
            data-slot="dialog-close"
          >
            <XIcon />
            <span className="sr-only">Close</span>
          </DialogPrimitive.Close>
        )}
      </DialogPrimitive.Content>
    </DialogPortal>
  );
}

function DialogHeader({ className, ...props }: React.ComponentProps<"div">) {
  return (
    <div
      className={cn("flex flex-col gap-2 text-center sm:text-left", className)}
      data-slot="dialog-header"
      {...props}
    />
  );
}

function DialogFooter({ className, ...props }: React.ComponentProps<"div">) {
  return (
    <div
      className={cn(
        "flex flex-col-reverse gap-2 sm:flex-row sm:justify-end",
        className
      )}
      data-slot="dialog-footer"
      {...props}
    />
  );
}

function DialogTitle({
  className,
  ...props
}: React.ComponentProps<typeof DialogPrimitive.Title>) {
  return (
    <DialogPrimitive.Title
      className={cn("font-semibold text-lg leading-none", className)}
      data-slot="dialog-title"
      {...props}
    />
  );
}

function DialogDescription({
  className,
  ...props
}: React.ComponentProps<typeof DialogPrimitive.Description>) {
  return (
    <DialogPrimitive.Description
      className={cn("text-muted-foreground text-sm", className)}
      data-slot="dialog-description"
      {...props}
    />
  );
}

export {
  Dialog,
  DialogClose,
  DialogContent,
  DialogDescription,
  DialogFooter,
  DialogHeader,
  DialogOverlay,
  DialogPortal,
  DialogTitle,
  DialogTrigger,
};
</file>

<file path="apps/web/src/components/ui/dropdown-menu.tsx">
"use client";

import { CheckIcon, ChevronRightIcon, CircleIcon } from "lucide-react";
import { DropdownMenu as DropdownMenuPrimitive } from "radix-ui";
import type * as React from "react";

import { cn } from "@/lib/utils";

function DropdownMenu({
  ...props
}: React.ComponentProps<typeof DropdownMenuPrimitive.Root>) {
  return <DropdownMenuPrimitive.Root data-slot="dropdown-menu" {...props} />;
}

function DropdownMenuPortal({
  ...props
}: React.ComponentProps<typeof DropdownMenuPrimitive.Portal>) {
  return (
    <DropdownMenuPrimitive.Portal data-slot="dropdown-menu-portal" {...props} />
  );
}

function DropdownMenuTrigger({
  ...props
}: React.ComponentProps<typeof DropdownMenuPrimitive.Trigger>) {
  return (
    <DropdownMenuPrimitive.Trigger
      data-slot="dropdown-menu-trigger"
      {...props}
    />
  );
}

function DropdownMenuContent({
  className,
  sideOffset = 4,
  ...props
}: React.ComponentProps<typeof DropdownMenuPrimitive.Content>) {
  return (
    <DropdownMenuPrimitive.Portal>
      <DropdownMenuPrimitive.Content
        className={cn(
          "data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2 z-50 max-h-(--radix-dropdown-menu-content-available-height) min-w-[8rem] origin-(--radix-dropdown-menu-content-transform-origin) overflow-y-auto overflow-x-hidden rounded-md border bg-popover p-1 text-popover-foreground shadow-md data-[state=closed]:animate-out data-[state=open]:animate-in",
          className
        )}
        data-slot="dropdown-menu-content"
        sideOffset={sideOffset}
        {...props}
      />
    </DropdownMenuPrimitive.Portal>
  );
}

function DropdownMenuGroup({
  ...props
}: React.ComponentProps<typeof DropdownMenuPrimitive.Group>) {
  return (
    <DropdownMenuPrimitive.Group data-slot="dropdown-menu-group" {...props} />
  );
}

function DropdownMenuItem({
  className,
  inset,
  variant = "default",
  ...props
}: React.ComponentProps<typeof DropdownMenuPrimitive.Item> & {
  inset?: boolean;
  variant?: "default" | "destructive";
}) {
  return (
    <DropdownMenuPrimitive.Item
      className={cn(
        "data-[variant=destructive]:*:[svg]:!text-destructive relative flex cursor-default select-none items-center gap-2 rounded-sm px-2 py-1.5 text-sm outline-hidden focus:bg-accent focus:text-accent-foreground data-[disabled]:pointer-events-none data-[inset]:pl-8 data-[variant=destructive]:text-destructive data-[disabled]:opacity-50 data-[variant=destructive]:focus:bg-destructive/10 data-[variant=destructive]:focus:text-destructive dark:data-[variant=destructive]:focus:bg-destructive/20 [&_svg:not([class*='size-'])]:size-4 [&_svg:not([class*='text-'])]:text-muted-foreground [&_svg]:pointer-events-none [&_svg]:shrink-0",
        className
      )}
      data-inset={inset}
      data-slot="dropdown-menu-item"
      data-variant={variant}
      {...props}
    />
  );
}

function DropdownMenuCheckboxItem({
  className,
  children,
  checked,
  ...props
}: React.ComponentProps<typeof DropdownMenuPrimitive.CheckboxItem>) {
  return (
    <DropdownMenuPrimitive.CheckboxItem
      checked={checked}
      className={cn(
        "relative flex cursor-default select-none items-center gap-2 rounded-sm py-1.5 pr-2 pl-8 text-sm outline-hidden focus:bg-accent focus:text-accent-foreground data-[disabled]:pointer-events-none data-[disabled]:opacity-50 [&_svg:not([class*='size-'])]:size-4 [&_svg]:pointer-events-none [&_svg]:shrink-0",
        className
      )}
      data-slot="dropdown-menu-checkbox-item"
      {...props}
    >
      <span className="pointer-events-none absolute left-2 flex size-3.5 items-center justify-center">
        <DropdownMenuPrimitive.ItemIndicator>
          <CheckIcon className="size-4" />
        </DropdownMenuPrimitive.ItemIndicator>
      </span>
      {children}
    </DropdownMenuPrimitive.CheckboxItem>
  );
}

function DropdownMenuRadioGroup({
  ...props
}: React.ComponentProps<typeof DropdownMenuPrimitive.RadioGroup>) {
  return (
    <DropdownMenuPrimitive.RadioGroup
      data-slot="dropdown-menu-radio-group"
      {...props}
    />
  );
}

function DropdownMenuRadioItem({
  className,
  children,
  ...props
}: React.ComponentProps<typeof DropdownMenuPrimitive.RadioItem>) {
  return (
    <DropdownMenuPrimitive.RadioItem
      className={cn(
        "relative flex cursor-default select-none items-center gap-2 rounded-sm py-1.5 pr-2 pl-8 text-sm outline-hidden focus:bg-accent focus:text-accent-foreground data-[disabled]:pointer-events-none data-[disabled]:opacity-50 [&_svg:not([class*='size-'])]:size-4 [&_svg]:pointer-events-none [&_svg]:shrink-0",
        className
      )}
      data-slot="dropdown-menu-radio-item"
      {...props}
    >
      <span className="pointer-events-none absolute left-2 flex size-3.5 items-center justify-center">
        <DropdownMenuPrimitive.ItemIndicator>
          <CircleIcon className="size-2 fill-current" />
        </DropdownMenuPrimitive.ItemIndicator>
      </span>
      {children}
    </DropdownMenuPrimitive.RadioItem>
  );
}

function DropdownMenuLabel({
  className,
  inset,
  ...props
}: React.ComponentProps<typeof DropdownMenuPrimitive.Label> & {
  inset?: boolean;
}) {
  return (
    <DropdownMenuPrimitive.Label
      className={cn(
        "px-2 py-1.5 font-medium text-sm data-[inset]:pl-8",
        className
      )}
      data-inset={inset}
      data-slot="dropdown-menu-label"
      {...props}
    />
  );
}

function DropdownMenuSeparator({
  className,
  ...props
}: React.ComponentProps<typeof DropdownMenuPrimitive.Separator>) {
  return (
    <DropdownMenuPrimitive.Separator
      className={cn("-mx-1 my-1 h-px bg-border", className)}
      data-slot="dropdown-menu-separator"
      {...props}
    />
  );
}

function DropdownMenuShortcut({
  className,
  ...props
}: React.ComponentProps<"span">) {
  return (
    <span
      className={cn(
        "ml-auto text-muted-foreground text-xs tracking-widest",
        className
      )}
      data-slot="dropdown-menu-shortcut"
      {...props}
    />
  );
}

function DropdownMenuSub({
  ...props
}: React.ComponentProps<typeof DropdownMenuPrimitive.Sub>) {
  return <DropdownMenuPrimitive.Sub data-slot="dropdown-menu-sub" {...props} />;
}

function DropdownMenuSubTrigger({
  className,
  inset,
  children,
  ...props
}: React.ComponentProps<typeof DropdownMenuPrimitive.SubTrigger> & {
  inset?: boolean;
}) {
  return (
    <DropdownMenuPrimitive.SubTrigger
      className={cn(
        "flex cursor-default select-none items-center rounded-sm px-2 py-1.5 text-sm outline-hidden focus:bg-accent focus:text-accent-foreground data-[state=open]:bg-accent data-[inset]:pl-8 data-[state=open]:text-accent-foreground",
        className
      )}
      data-inset={inset}
      data-slot="dropdown-menu-sub-trigger"
      {...props}
    >
      {children}
      <ChevronRightIcon className="ml-auto size-4" />
    </DropdownMenuPrimitive.SubTrigger>
  );
}

function DropdownMenuSubContent({
  className,
  ...props
}: React.ComponentProps<typeof DropdownMenuPrimitive.SubContent>) {
  return (
    <DropdownMenuPrimitive.SubContent
      className={cn(
        "data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2 z-50 min-w-[8rem] origin-(--radix-dropdown-menu-content-transform-origin) overflow-hidden rounded-md border bg-popover p-1 text-popover-foreground shadow-lg data-[state=closed]:animate-out data-[state=open]:animate-in",
        className
      )}
      data-slot="dropdown-menu-sub-content"
      {...props}
    />
  );
}

export {
  DropdownMenu,
  DropdownMenuPortal,
  DropdownMenuTrigger,
  DropdownMenuContent,
  DropdownMenuGroup,
  DropdownMenuLabel,
  DropdownMenuItem,
  DropdownMenuCheckboxItem,
  DropdownMenuRadioGroup,
  DropdownMenuRadioItem,
  DropdownMenuSeparator,
  DropdownMenuShortcut,
  DropdownMenuSub,
  DropdownMenuSubTrigger,
  DropdownMenuSubContent,
};
</file>

<file path="apps/web/src/components/ui/input.tsx">
import type * as React from "react";

import { cn } from "@/lib/utils";

function Input({ className, type, ...props }: React.ComponentProps<"input">) {
  return (
    <input
      className={cn(
        "flex h-9 w-full min-w-0 rounded-md border border-input bg-transparent px-3 py-1 text-base shadow-xs outline-none transition-[color,box-shadow] selection:bg-primary selection:text-primary-foreground file:inline-flex file:h-7 file:border-0 file:bg-transparent file:font-medium file:text-foreground file:text-sm placeholder:text-muted-foreground disabled:pointer-events-none disabled:cursor-not-allowed disabled:opacity-50 md:text-sm dark:bg-input/30",
        "focus-visible:border-ring focus-visible:ring-[3px] focus-visible:ring-ring/50",
        "aria-invalid:border-destructive aria-invalid:ring-destructive/20 dark:aria-invalid:ring-destructive/40",
        className
      )}
      data-slot="input"
      type={type}
      {...props}
    />
  );
}

export { Input };
</file>

<file path="apps/web/src/components/ui/label.tsx">
import { Label as LabelPrimitive } from "radix-ui";
import type * as React from "react";

import { cn } from "@/lib/utils";

function Label({
  className,
  ...props
}: React.ComponentProps<typeof LabelPrimitive.Root>) {
  return (
    <LabelPrimitive.Root
      className={cn(
        "flex select-none items-center gap-2 font-medium text-sm leading-none peer-disabled:cursor-not-allowed peer-disabled:opacity-50 group-data-[disabled=true]:pointer-events-none group-data-[disabled=true]:opacity-50",
        className
      )}
      data-slot="label"
      {...props}
    />
  );
}

export { Label };
</file>

<file path="apps/web/src/components/ui/skeleton.tsx">
import { cn } from "@/lib/utils";

function Skeleton({ className, ...props }: React.ComponentProps<"div">) {
  return (
    <div
      className={cn("animate-pulse rounded-md bg-accent", className)}
      data-slot="skeleton"
      {...props}
    />
  );
}

export { Skeleton };
</file>

<file path="apps/web/src/components/ui/sonner.tsx">
"use client";

import { useTheme } from "next-themes";
import { Toaster as Sonner, type ToasterProps } from "sonner";

const Toaster = ({ ...props }: ToasterProps) => {
  const { theme = "system" } = useTheme();

  return (
    <Sonner
      className="toaster group"
      style={
        {
          "--normal-bg": "var(--popover)",
          "--normal-text": "var(--popover-foreground)",
          "--normal-border": "var(--border)",
        } as React.CSSProperties
      }
      theme={theme as ToasterProps["theme"]}
      {...props}
    />
  );
};

export { Toaster };
</file>

<file path="apps/web/src/lib/auth-client.ts">
import { createAuthClient } from "better-auth/react";

export const authClient = createAuthClient({
  baseURL: import.meta.env.VITE_SERVER_URL,
});
</file>

<file path="apps/web/src/lib/utils.ts">
import { type ClassValue, clsx } from "clsx";
import { twMerge } from "tailwind-merge";

export function cn(...inputs: ClassValue[]) {
  return twMerge(clsx(inputs));
}
</file>

<file path="apps/web/tsconfig.json">
{
  "compilerOptions": {
    "strict": true,
    "esModuleInterop": true,
    "jsx": "react-jsx",
    "target": "ESNext",
    "module": "ESNext",
    "moduleResolution": "Bundler",
    "verbatimModuleSyntax": true,
    "skipLibCheck": true,
    "types": ["vite/client"],
    "rootDirs": ["."],
    "baseUrl": ".",
    "paths": {
      "@/*": ["./src/*"]
    },
    "strictNullChecks": true
  }
}
</file>

<file path="apps/web/vite.config.ts">
import path from "node:path";
import tailwindcss from "@tailwindcss/vite";
import { tanstackRouter } from "@tanstack/router-plugin/vite";
import react from "@vitejs/plugin-react";
import { defineConfig } from "vite";

export default defineConfig({
  plugins: [tailwindcss(), tanstackRouter({}), react()],
  resolve: {
    alias: {
      "@": path.resolve(__dirname, "./src"),
    },
  },
});
</file>

<file path="package.json">
{
  "name": "xquery",
  "private": true,
  "type": "module",
  "workspaces": {
    "packages": [
      "apps/*",
      "packages/*"
    ],
    "catalog": {
      "hono": "^4.8.2",
      "@trpc/server": "^11.5.0",
      "better-auth": "^1.4.5",
      "dotenv": "^17.2.2",
      "zod": "^4.1.13",
      "@trpc/client": "^11.5.0"
    }
  },
  "scripts": {
    "check": "biome check --write .",
    "prepare": "husky",
    "dev": "turbo dev",
    "build": "turbo build",
    "check-types": "turbo check-types",
    "dev:native": "turbo -F native dev",
    "dev:web": "turbo -F web dev",
    "dev:server": "turbo -F server dev",
    "db:push": "turbo -F @xquery/db db:push",
    "db:studio": "turbo -F @xquery/db db:studio",
    "db:generate": "turbo -F @xquery/db db:generate",
    "db:migrate": "turbo -F @xquery/db db:migrate",
    "test": "turbo test",
    "test:web": "turbo -F web test:run",
    "test:api": "turbo -F @xquery/api test:run"
  },
  "dependencies": {
    "dotenv": "^17.2.2",
    "zod": "^4.1.13"
  },
  "devDependencies": {
    "turbo": "^2.5.4",
    "@biomejs/biome": "2.3.8",
    "ultracite": "6.3.10",
    "husky": "^9.1.7",
    "lint-staged": "^16.1.2",
    "@types/bun": "^1.2.6"
  },
  "lint-staged": {
    "*.{js,jsx,ts,tsx,json,jsonc,css,scss,md,mdx}": [
      "bun x ultracite fix"
    ]
  },
  "packageManager": "bun@1.3.1"
}
</file>

<file path="packages/api/src/context.ts">
import { auth } from "@xquery/auth";
import type { Context as HonoContext } from "hono";

export type CreateContextOptions = {
  context: HonoContext;
};

export async function createContext({ context }: CreateContextOptions) {
  const session = await auth.api.getSession({
    headers: context.req.raw.headers,
  });
  return {
    session,
  };
}

export type Context = Awaited<ReturnType<typeof createContext>>;
</file>

<file path="packages/api/src/index.ts">
import { initTRPC, TRPCError } from "@trpc/server";
import type { Context } from "./context";

export const t = initTRPC.context<Context>().create();

export const router = t.router;

export const publicProcedure = t.procedure;

export const protectedProcedure = t.procedure.use(({ ctx, next }) => {
  if (!ctx.session) {
    throw new TRPCError({
      code: "UNAUTHORIZED",
      message: "Authentication required",
      cause: "No session",
    });
  }
  return next({
    ctx: {
      ...ctx,
      session: ctx.session,
    },
  });
});
</file>

<file path="packages/api/src/routers/chat.ts">
import { TRPCError } from "@trpc/server";
import {
  and,
  asc,
  chat,
  chatMessage,
  count,
  DOCUMENTS_BUCKET,
  db,
  desc,
  eq,
  file,
  ilike,
  or,
  supabaseAdmin,
} from "@xquery/db";
import { z } from "zod";
import { protectedProcedure, router } from "../index";
import { getOrCreateAssistant, openai } from "../lib/openai";

export const chatRouter = router({
  create: protectedProcedure
    .input(z.object({ fileId: z.string().uuid() }))
    .mutation(async ({ ctx, input }) => {
      const userId = ctx.session.user.id;

      const fileResult = await db
        .select()
        .from(file)
        .where(and(eq(file.id, input.fileId), eq(file.userId, userId)))
        .limit(1);

      const fileRecord = fileResult[0];
      if (!fileRecord) {
        throw new TRPCError({
          code: "NOT_FOUND",
          message: "File not found",
        });
      }

      const thread = await openai.beta.threads.create();

      const chatId = crypto.randomUUID();
      await db.insert(chat).values({
        id: chatId,
        userId,
        fileId: input.fileId,
        openaiThreadId: thread.id,
      });

      return {
        chatId,
        fileId: input.fileId,
        fileName: fileRecord.name,
        title: null,
        createdAt: new Date(),
        updatedAt: new Date(),
      };
    }),

  list: protectedProcedure
    .input(
      z
        .object({
          fileId: z.string().uuid().optional(),
          limit: z.number().int().min(1).max(100).default(50),
          offset: z.number().int().min(0).default(0),
        })
        .optional()
    )
    .query(async ({ ctx, input }) => {
      const userId = ctx.session.user.id;
      const limit = input?.limit ?? 50;
      const offset = input?.offset ?? 0;

      const whereConditions = input?.fileId
        ? and(eq(chat.userId, userId), eq(chat.fileId, input.fileId))
        : eq(chat.userId, userId);

      const chats = await db
        .select({
          id: chat.id,
          title: chat.title,
          fileId: chat.fileId,
          fileName: file.name,
          createdAt: chat.createdAt,
          updatedAt: chat.updatedAt,
        })
        .from(chat)
        .innerJoin(file, eq(chat.fileId, file.id))
        .where(whereConditions)
        .orderBy(desc(chat.updatedAt))
        .limit(limit)
        .offset(offset);

      const chatIds = chats.map((c) => c.id);
      const messageCounts =
        chatIds.length > 0
          ? await Promise.all(
              chatIds.map(async (chatId) => {
                const result = await db
                  .select({ count: count() })
                  .from(chatMessage)
                  .where(eq(chatMessage.chatId, chatId));
                return { chatId, count: result[0]?.count ?? 0 };
              })
            )
          : [];

      const countMap = new Map(
        messageCounts.map((mc) => [mc.chatId, mc.count])
      );

      return chats.map((c) => ({
        ...c,
        messageCount: countMap.get(c.id) ?? 0,
      }));
    }),

  search: protectedProcedure
    .input(
      z.object({
        fileId: z.string().uuid(),
        query: z.string().min(1).max(500),
        limit: z.number().int().min(1).max(50).default(20),
      })
    )
    .query(async ({ ctx, input }) => {
      const userId = ctx.session.user.id;

      // Sanitize query for LIKE pattern
      const sanitizedQuery = input.query
        .replace(/\\/g, "\\\\")
        .replace(/%/g, "\\%")
        .replace(/_/g, "\\_");

      // Search messages in chats for this file
      const matchingMessages = await db
        .select({
          messageId: chatMessage.id,
          chatId: chatMessage.chatId,
          role: chatMessage.role,
          content: chatMessage.content,
          messageCreatedAt: chatMessage.createdAt,
          chatTitle: chat.title,
          chatUpdatedAt: chat.updatedAt,
        })
        .from(chatMessage)
        .innerJoin(chat, eq(chatMessage.chatId, chat.id))
        .where(
          and(
            eq(chat.fileId, input.fileId),
            eq(chat.userId, userId),
            or(
              ilike(chatMessage.content, `%${sanitizedQuery}%`),
              ilike(chat.title, `%${sanitizedQuery}%`)
            )
          )
        )
        .orderBy(desc(chat.updatedAt), desc(chatMessage.createdAt))
        .limit(input.limit * 5);

      // Group by chat
      const chatMap = new Map<
        string,
        {
          id: string;
          title: string | null;
          updatedAt: Date;
          matchingMessages: Array<{
            id: string;
            role: "user" | "assistant";
            content: string;
            createdAt: Date;
          }>;
        }
      >();

      for (const msg of matchingMessages) {
        if (!chatMap.has(msg.chatId)) {
          chatMap.set(msg.chatId, {
            id: msg.chatId,
            title: msg.chatTitle,
            updatedAt: msg.chatUpdatedAt,
            matchingMessages: [],
          });
        }
        const chatEntry = chatMap.get(msg.chatId);
        if (chatEntry && chatEntry.matchingMessages.length < 5) {
          chatEntry.matchingMessages.push({
            id: msg.messageId,
            role: msg.role as "user" | "assistant",
            content: msg.content,
            createdAt: msg.messageCreatedAt,
          });
        }
      }

      return {
        chats: Array.from(chatMap.values()).slice(0, input.limit),
      };
    }),

  get: protectedProcedure
    .input(z.object({ chatId: z.string().uuid() }))
    .query(async ({ ctx, input }) => {
      const userId = ctx.session.user.id;

      const chatResult = await db
        .select({
          id: chat.id,
          title: chat.title,
          fileId: chat.fileId,
          fileName: file.name,
          openaiThreadId: chat.openaiThreadId,
          createdAt: chat.createdAt,
          updatedAt: chat.updatedAt,
        })
        .from(chat)
        .innerJoin(file, eq(chat.fileId, file.id))
        .where(and(eq(chat.id, input.chatId), eq(chat.userId, userId)))
        .limit(1);

      const chatRecord = chatResult[0];
      if (!chatRecord) {
        throw new TRPCError({
          code: "NOT_FOUND",
          message: "Chat not found",
        });
      }

      const messages = await db
        .select({
          id: chatMessage.id,
          role: chatMessage.role,
          content: chatMessage.content,
          createdAt: chatMessage.createdAt,
        })
        .from(chatMessage)
        .where(eq(chatMessage.chatId, input.chatId))
        .orderBy(asc(chatMessage.createdAt));

      return {
        ...chatRecord,
        messages,
      };
    }),

  delete: protectedProcedure
    .input(z.object({ chatId: z.string().uuid() }))
    .mutation(async ({ ctx, input }) => {
      const userId = ctx.session.user.id;

      const result = await db
        .delete(chat)
        .where(and(eq(chat.id, input.chatId), eq(chat.userId, userId)))
        .returning({ id: chat.id });

      if (result.length === 0) {
        throw new TRPCError({
          code: "NOT_FOUND",
          message: "Chat not found",
        });
      }

      return { success: true };
    }),

  rename: protectedProcedure
    .input(
      z.object({
        chatId: z.string().uuid(),
        title: z.string().min(1).max(255),
      })
    )
    .mutation(async ({ ctx, input }) => {
      const userId = ctx.session.user.id;

      const result = await db
        .update(chat)
        .set({ title: input.title })
        .where(and(eq(chat.id, input.chatId), eq(chat.userId, userId)))
        .returning({ id: chat.id });

      if (result.length === 0) {
        throw new TRPCError({
          code: "NOT_FOUND",
          message: "Chat not found",
        });
      }

      return { success: true };
    }),

  askQuestion: protectedProcedure
    .input(
      z.object({
        chatId: z.string().uuid(),
        question: z.string().min(1).max(2000),
      })
    )
    // biome-ignore lint/complexity/noExcessiveCognitiveComplexity: orchestrating OpenAI API requires multiple steps
    .mutation(async ({ ctx, input }) => {
      const userId = ctx.session.user.id;

      const chatResult = await db
        .select({
          id: chat.id,
          fileId: chat.fileId,
          openaiThreadId: chat.openaiThreadId,
          title: chat.title,
        })
        .from(chat)
        .where(and(eq(chat.id, input.chatId), eq(chat.userId, userId)))
        .limit(1);

      const chatRecord = chatResult[0];
      if (!chatRecord) {
        throw new TRPCError({
          code: "NOT_FOUND",
          message: "Chat not found",
        });
      }

      const fileResult = await db
        .select()
        .from(file)
        .where(eq(file.id, chatRecord.fileId))
        .limit(1);

      const fileRecord = fileResult[0];
      if (!fileRecord) {
        throw new TRPCError({
          code: "NOT_FOUND",
          message: "File not found",
        });
      }

      let openaiFileId = fileRecord.openaiFileId;

      if (!openaiFileId) {
        const { data: fileData, error: downloadError } =
          await supabaseAdmin.storage
            .from(DOCUMENTS_BUCKET)
            .download(fileRecord.storagePath);

        if (downloadError || !fileData) {
          throw new TRPCError({
            code: "INTERNAL_SERVER_ERROR",
            message: "Failed to download file from storage",
          });
        }

        const openaiFile = await openai.files.create({
          file: new File([fileData], fileRecord.originalFilename, {
            type: fileRecord.mimeType,
          }),
          purpose: "assistants",
        });

        openaiFileId = openaiFile.id;

        await db
          .update(file)
          .set({ openaiFileId })
          .where(eq(file.id, chatRecord.fileId));
      }

      const userMessageId = crypto.randomUUID();
      await db.insert(chatMessage).values({
        id: userMessageId,
        chatId: input.chatId,
        role: "user",
        content: input.question,
      });

      const isFirstMessage = !chatRecord.title;

      if (isFirstMessage) {
        const title =
          input.question.length > 50
            ? `${input.question.substring(0, 50)}...`
            : input.question;
        await db.update(chat).set({ title }).where(eq(chat.id, input.chatId));
      }

      const assistantId = await getOrCreateAssistant();

      const messageCount = await db
        .select({ count: count() })
        .from(chatMessage)
        .where(eq(chatMessage.chatId, input.chatId));

      const isFirstChatMessage = (messageCount[0]?.count ?? 0) <= 1;

      if (isFirstChatMessage) {
        await openai.beta.threads.messages.create(chatRecord.openaiThreadId, {
          role: "user",
          content: input.question,
          attachments: [
            {
              file_id: openaiFileId,
              tools: [{ type: "file_search" }],
            },
          ],
        });
      } else {
        await openai.beta.threads.messages.create(chatRecord.openaiThreadId, {
          role: "user",
          content: input.question,
        });
      }

      const run = await openai.beta.threads.runs.createAndPoll(
        chatRecord.openaiThreadId,
        {
          assistant_id: assistantId,
        }
      );

      if (run.status !== "completed") {
        throw new TRPCError({
          code: "INTERNAL_SERVER_ERROR",
          message: `Assistant run failed with status: ${run.status}`,
        });
      }

      const messages = await openai.beta.threads.messages.list(
        chatRecord.openaiThreadId,
        {
          order: "desc",
          limit: 1,
        }
      );

      const assistantMessage = messages.data[0];
      if (!assistantMessage || assistantMessage.role !== "assistant") {
        throw new TRPCError({
          code: "INTERNAL_SERVER_ERROR",
          message: "No assistant response found",
        });
      }

      const textContent = assistantMessage.content.find(
        (c) => c.type === "text"
      );
      if (!textContent || textContent.type !== "text") {
        throw new TRPCError({
          code: "INTERNAL_SERVER_ERROR",
          message: "No text content in response",
        });
      }

      const assistantMessageId = crypto.randomUUID();
      await db.insert(chatMessage).values({
        id: assistantMessageId,
        chatId: input.chatId,
        role: "assistant",
        content: textContent.text.value,
      });

      return {
        answer: textContent.text.value,
        userMessageId,
        assistantMessageId,
      };
    }),

  syncFileToOpenAI: protectedProcedure
    .input(z.object({ fileId: z.string().uuid() }))
    .mutation(async ({ ctx, input }) => {
      const userId = ctx.session.user.id;

      const result = await db
        .select()
        .from(file)
        .where(and(eq(file.id, input.fileId), eq(file.userId, userId)))
        .limit(1);

      const fileRecord = result[0];
      if (!fileRecord) {
        throw new TRPCError({
          code: "NOT_FOUND",
          message: "File not found",
        });
      }

      if (fileRecord.openaiFileId) {
        return { openaiFileId: fileRecord.openaiFileId, alreadySynced: true };
      }

      const { data: fileData, error: downloadError } =
        await supabaseAdmin.storage
          .from(DOCUMENTS_BUCKET)
          .download(fileRecord.storagePath);

      if (downloadError || !fileData) {
        throw new TRPCError({
          code: "INTERNAL_SERVER_ERROR",
          message: "Failed to download file from storage",
        });
      }

      const openaiFile = await openai.files.create({
        file: new File([fileData], fileRecord.originalFilename, {
          type: fileRecord.mimeType,
        }),
        purpose: "assistants",
      });

      await db
        .update(file)
        .set({ openaiFileId: openaiFile.id })
        .where(eq(file.id, input.fileId));

      return { openaiFileId: openaiFile.id, alreadySynced: false };
    }),

  getFileStatus: protectedProcedure
    .input(z.object({ fileId: z.string().uuid() }))
    .query(async ({ ctx, input }) => {
      const userId = ctx.session.user.id;

      const result = await db
        .select({ openaiFileId: file.openaiFileId })
        .from(file)
        .where(and(eq(file.id, input.fileId), eq(file.userId, userId)))
        .limit(1);

      const fileRecord = result[0];
      if (!fileRecord) {
        throw new TRPCError({
          code: "NOT_FOUND",
          message: "File not found",
        });
      }

      return { synced: !!fileRecord.openaiFileId };
    }),
});
</file>

<file path="packages/api/tsconfig.json">
{
  "extends": "@xquery/config/tsconfig.base.json",
  "compilerOptions": {
    "declaration": true,
    "declarationMap": true,
    "sourceMap": true,
    "outDir": "dist",
    "composite": true,
    "strictNullChecks": true
  }
}
</file>

<file path="packages/auth/tsconfig.json">
{
  "extends": "@xquery/config/tsconfig.base.json",
  "compilerOptions": {
    "declaration": true,
    "declarationMap": true,
    "sourceMap": true,
    "outDir": "dist",
    "composite": true,
    "strictNullChecks": true
  }
}
</file>

<file path="packages/config/package.json">
{
  "name": "@xquery/config",
  "version": "0.0.0",
  "private": true
}
</file>

<file path="packages/config/tsconfig.base.json">
{
  "$schema": "https://json.schemastore.org/tsconfig",
  "compilerOptions": {
    "target": "ESNext",
    "module": "ESNext",
    "moduleResolution": "bundler",
    "lib": ["ESNext"],
    "verbatimModuleSyntax": true,
    "strict": true,
    "skipLibCheck": true,
    "resolveJsonModule": true,
    "allowSyntheticDefaultImports": true,
    "esModuleInterop": true,
    "forceConsistentCasingInFileNames": true,
    "isolatedModules": true,
    "noUncheckedIndexedAccess": true,
    "noUnusedLocals": true,
    "noUnusedParameters": true,
    "noFallthroughCasesInSwitch": true,
    "types": ["bun"],
    "strictNullChecks": true
  }
}
</file>

<file path="packages/db/drizzle.config.ts">
import dotenv from "dotenv";
import { defineConfig } from "drizzle-kit";

dotenv.config({
  path: "../../apps/server/.env",
});

export default defineConfig({
  schema: "./src/schema",
  out: "./src/migrations",
  dialect: "postgresql",
  dbCredentials: {
    url: process.env.DATABASE_URL || "",
  },
});
</file>

<file path="packages/db/package.json">
{
  "name": "@xquery/db",
  "type": "module",
  "exports": {
    ".": {
      "default": "./src/index.ts"
    },
    "./*": {
      "default": "./src/*.ts"
    }
  },
  "scripts": {
    "db:push": "drizzle-kit push",
    "db:studio": "drizzle-kit studio",
    "db:generate": "drizzle-kit generate",
    "db:migrate": "drizzle-kit migrate"
  },
  "devDependencies": {
    "drizzle-kit": "^0.31.8",
    "@types/pg": "^8.15.6",
    "@xquery/config": "workspace:*"
  },
  "peerDependencies": {
    "typescript": "^5"
  },
  "dependencies": {
    "@supabase/supabase-js": "^2.49.4",
    "drizzle-orm": "^0.45.0",
    "pg": "^8.16.3",
    "dotenv": "catalog:",
    "zod": "catalog:"
  }
}
</file>

<file path="packages/db/src/migrations/meta/_journal.json">
{
  "version": "7",
  "dialect": "postgresql",
  "entries": [
    {
      "idx": 0,
      "version": "7",
      "when": 1765470839834,
      "tag": "0000_giant_komodo",
      "breakpoints": true
    },
    {
      "idx": 1,
      "version": "7",
      "when": 1765472161106,
      "tag": "0001_violet_wildside",
      "breakpoints": true
    }
  ]
}
</file>

<file path="packages/db/src/migrations/meta/0000_snapshot.json">
{
  "id": "13252420-bfe8-4878-b599-bdb983076fe9",
  "prevId": "00000000-0000-0000-0000-000000000000",
  "version": "7",
  "dialect": "postgresql",
  "tables": {
    "public.account": {
      "name": "account",
      "schema": "",
      "columns": {
        "id": {
          "name": "id",
          "type": "text",
          "primaryKey": true,
          "notNull": true
        },
        "account_id": {
          "name": "account_id",
          "type": "text",
          "primaryKey": false,
          "notNull": true
        },
        "provider_id": {
          "name": "provider_id",
          "type": "text",
          "primaryKey": false,
          "notNull": true
        },
        "user_id": {
          "name": "user_id",
          "type": "text",
          "primaryKey": false,
          "notNull": true
        },
        "access_token": {
          "name": "access_token",
          "type": "text",
          "primaryKey": false,
          "notNull": false
        },
        "refresh_token": {
          "name": "refresh_token",
          "type": "text",
          "primaryKey": false,
          "notNull": false
        },
        "id_token": {
          "name": "id_token",
          "type": "text",
          "primaryKey": false,
          "notNull": false
        },
        "access_token_expires_at": {
          "name": "access_token_expires_at",
          "type": "timestamp",
          "primaryKey": false,
          "notNull": false
        },
        "refresh_token_expires_at": {
          "name": "refresh_token_expires_at",
          "type": "timestamp",
          "primaryKey": false,
          "notNull": false
        },
        "scope": {
          "name": "scope",
          "type": "text",
          "primaryKey": false,
          "notNull": false
        },
        "password": {
          "name": "password",
          "type": "text",
          "primaryKey": false,
          "notNull": false
        },
        "created_at": {
          "name": "created_at",
          "type": "timestamp",
          "primaryKey": false,
          "notNull": true,
          "default": "now()"
        },
        "updated_at": {
          "name": "updated_at",
          "type": "timestamp",
          "primaryKey": false,
          "notNull": true
        }
      },
      "indexes": {
        "account_userId_idx": {
          "name": "account_userId_idx",
          "columns": [
            {
              "expression": "user_id",
              "isExpression": false,
              "asc": true,
              "nulls": "last"
            }
          ],
          "isUnique": false,
          "concurrently": false,
          "method": "btree",
          "with": {}
        }
      },
      "foreignKeys": {
        "account_user_id_user_id_fk": {
          "name": "account_user_id_user_id_fk",
          "tableFrom": "account",
          "tableTo": "user",
          "columnsFrom": ["user_id"],
          "columnsTo": ["id"],
          "onDelete": "cascade",
          "onUpdate": "no action"
        }
      },
      "compositePrimaryKeys": {},
      "uniqueConstraints": {},
      "policies": {},
      "checkConstraints": {},
      "isRLSEnabled": false
    },
    "public.session": {
      "name": "session",
      "schema": "",
      "columns": {
        "id": {
          "name": "id",
          "type": "text",
          "primaryKey": true,
          "notNull": true
        },
        "expires_at": {
          "name": "expires_at",
          "type": "timestamp",
          "primaryKey": false,
          "notNull": true
        },
        "token": {
          "name": "token",
          "type": "text",
          "primaryKey": false,
          "notNull": true
        },
        "created_at": {
          "name": "created_at",
          "type": "timestamp",
          "primaryKey": false,
          "notNull": true,
          "default": "now()"
        },
        "updated_at": {
          "name": "updated_at",
          "type": "timestamp",
          "primaryKey": false,
          "notNull": true
        },
        "ip_address": {
          "name": "ip_address",
          "type": "text",
          "primaryKey": false,
          "notNull": false
        },
        "user_agent": {
          "name": "user_agent",
          "type": "text",
          "primaryKey": false,
          "notNull": false
        },
        "user_id": {
          "name": "user_id",
          "type": "text",
          "primaryKey": false,
          "notNull": true
        }
      },
      "indexes": {
        "session_userId_idx": {
          "name": "session_userId_idx",
          "columns": [
            {
              "expression": "user_id",
              "isExpression": false,
              "asc": true,
              "nulls": "last"
            }
          ],
          "isUnique": false,
          "concurrently": false,
          "method": "btree",
          "with": {}
        }
      },
      "foreignKeys": {
        "session_user_id_user_id_fk": {
          "name": "session_user_id_user_id_fk",
          "tableFrom": "session",
          "tableTo": "user",
          "columnsFrom": ["user_id"],
          "columnsTo": ["id"],
          "onDelete": "cascade",
          "onUpdate": "no action"
        }
      },
      "compositePrimaryKeys": {},
      "uniqueConstraints": {
        "session_token_unique": {
          "name": "session_token_unique",
          "nullsNotDistinct": false,
          "columns": ["token"]
        }
      },
      "policies": {},
      "checkConstraints": {},
      "isRLSEnabled": false
    },
    "public.user": {
      "name": "user",
      "schema": "",
      "columns": {
        "id": {
          "name": "id",
          "type": "text",
          "primaryKey": true,
          "notNull": true
        },
        "name": {
          "name": "name",
          "type": "text",
          "primaryKey": false,
          "notNull": true
        },
        "email": {
          "name": "email",
          "type": "text",
          "primaryKey": false,
          "notNull": true
        },
        "email_verified": {
          "name": "email_verified",
          "type": "boolean",
          "primaryKey": false,
          "notNull": true,
          "default": false
        },
        "image": {
          "name": "image",
          "type": "text",
          "primaryKey": false,
          "notNull": false
        },
        "created_at": {
          "name": "created_at",
          "type": "timestamp",
          "primaryKey": false,
          "notNull": true,
          "default": "now()"
        },
        "updated_at": {
          "name": "updated_at",
          "type": "timestamp",
          "primaryKey": false,
          "notNull": true,
          "default": "now()"
        }
      },
      "indexes": {},
      "foreignKeys": {},
      "compositePrimaryKeys": {},
      "uniqueConstraints": {
        "user_email_unique": {
          "name": "user_email_unique",
          "nullsNotDistinct": false,
          "columns": ["email"]
        }
      },
      "policies": {},
      "checkConstraints": {},
      "isRLSEnabled": false
    },
    "public.verification": {
      "name": "verification",
      "schema": "",
      "columns": {
        "id": {
          "name": "id",
          "type": "text",
          "primaryKey": true,
          "notNull": true
        },
        "identifier": {
          "name": "identifier",
          "type": "text",
          "primaryKey": false,
          "notNull": true
        },
        "value": {
          "name": "value",
          "type": "text",
          "primaryKey": false,
          "notNull": true
        },
        "expires_at": {
          "name": "expires_at",
          "type": "timestamp",
          "primaryKey": false,
          "notNull": true
        },
        "created_at": {
          "name": "created_at",
          "type": "timestamp",
          "primaryKey": false,
          "notNull": true,
          "default": "now()"
        },
        "updated_at": {
          "name": "updated_at",
          "type": "timestamp",
          "primaryKey": false,
          "notNull": true,
          "default": "now()"
        }
      },
      "indexes": {
        "verification_identifier_idx": {
          "name": "verification_identifier_idx",
          "columns": [
            {
              "expression": "identifier",
              "isExpression": false,
              "asc": true,
              "nulls": "last"
            }
          ],
          "isUnique": false,
          "concurrently": false,
          "method": "btree",
          "with": {}
        }
      },
      "foreignKeys": {},
      "compositePrimaryKeys": {},
      "uniqueConstraints": {},
      "policies": {},
      "checkConstraints": {},
      "isRLSEnabled": false
    }
  },
  "enums": {},
  "schemas": {},
  "sequences": {},
  "roles": {},
  "policies": {},
  "views": {},
  "_meta": {
    "columns": {},
    "schemas": {},
    "tables": {}
  }
}
</file>

<file path="packages/db/src/schema/auth.ts">
import { relations } from "drizzle-orm";
import { boolean, index, pgTable, text, timestamp } from "drizzle-orm/pg-core";
import { file } from "./files";

export const user = pgTable("user", {
  id: text("id").primaryKey(),
  name: text("name").notNull(),
  email: text("email").notNull().unique(),
  emailVerified: boolean("email_verified").default(false).notNull(),
  image: text("image"),
  createdAt: timestamp("created_at").defaultNow().notNull(),
  updatedAt: timestamp("updated_at")
    .defaultNow()
    .$onUpdate(() => /* @__PURE__ */ new Date())
    .notNull(),
});

export const session = pgTable(
  "session",
  {
    id: text("id").primaryKey(),
    expiresAt: timestamp("expires_at").notNull(),
    token: text("token").notNull().unique(),
    createdAt: timestamp("created_at").defaultNow().notNull(),
    updatedAt: timestamp("updated_at")
      .$onUpdate(() => /* @__PURE__ */ new Date())
      .notNull(),
    ipAddress: text("ip_address"),
    userAgent: text("user_agent"),
    userId: text("user_id")
      .notNull()
      .references(() => user.id, { onDelete: "cascade" }),
  },
  (table) => [index("session_userId_idx").on(table.userId)]
);

export const account = pgTable(
  "account",
  {
    id: text("id").primaryKey(),
    accountId: text("account_id").notNull(),
    providerId: text("provider_id").notNull(),
    userId: text("user_id")
      .notNull()
      .references(() => user.id, { onDelete: "cascade" }),
    accessToken: text("access_token"),
    refreshToken: text("refresh_token"),
    idToken: text("id_token"),
    accessTokenExpiresAt: timestamp("access_token_expires_at"),
    refreshTokenExpiresAt: timestamp("refresh_token_expires_at"),
    scope: text("scope"),
    password: text("password"),
    createdAt: timestamp("created_at").defaultNow().notNull(),
    updatedAt: timestamp("updated_at")
      .$onUpdate(() => /* @__PURE__ */ new Date())
      .notNull(),
  },
  (table) => [index("account_userId_idx").on(table.userId)]
);

export const verification = pgTable(
  "verification",
  {
    id: text("id").primaryKey(),
    identifier: text("identifier").notNull(),
    value: text("value").notNull(),
    expiresAt: timestamp("expires_at").notNull(),
    createdAt: timestamp("created_at").defaultNow().notNull(),
    updatedAt: timestamp("updated_at")
      .defaultNow()
      .$onUpdate(() => /* @__PURE__ */ new Date())
      .notNull(),
  },
  (table) => [index("verification_identifier_idx").on(table.identifier)]
);

export const userRelations = relations(user, ({ many }) => ({
  sessions: many(session),
  accounts: many(account),
  files: many(file),
}));

export const sessionRelations = relations(session, ({ one }) => ({
  user: one(user, {
    fields: [session.userId],
    references: [user.id],
  }),
}));

export const accountRelations = relations(account, ({ one }) => ({
  user: one(user, {
    fields: [account.userId],
    references: [user.id],
  }),
}));
</file>

<file path="packages/db/supabase/config.toml">
# For detailed configuration reference documentation, visit:
# https://supabase.com/docs/guides/local-development/cli/config
# A string used to distinguish different Supabase projects on the same host. Defaults to the
# working directory name when running `supabase init`.
project_id = "db"

[api]
enabled = true
# Port to use for the API URL.
port = 54321
# Schemas to expose in your API. Tables, views and stored procedures in this schema will get API
# endpoints. `public` and `graphql_public` schemas are included by default.
schemas = ["public", "graphql_public"]
# Extra schemas to add to the search_path of every request.
extra_search_path = ["public", "extensions"]
# The maximum number of rows returns from a view, table, or stored procedure. Limits payload size
# for accidental or malicious requests.
max_rows = 1000

[api.tls]
# Enable HTTPS endpoints locally using a self-signed certificate.
enabled = false
# Paths to self-signed certificate pair.
# cert_path = "../certs/my-cert.pem"
# key_path = "../certs/my-key.pem"

[db]
# Port to use for the local database URL.
port = 54322
# Port used by db diff command to initialize the shadow database.
shadow_port = 54320
# The database major version to use. This has to be the same as your remote database's. Run `SHOW
# server_version;` on the remote database to check.
major_version = 17

[db.pooler]
enabled = false
# Port to use for the local connection pooler.
port = 54329
# Specifies when a server connection can be reused by other clients.
# Configure one of the supported pooler modes: `transaction`, `session`.
pool_mode = "transaction"
# How many server connections to allow per user/database pair.
default_pool_size = 20
# Maximum number of client connections allowed.
max_client_conn = 100

# [db.vault]
# secret_key = "env(SECRET_VALUE)"

[db.migrations]
# If disabled, migrations will be skipped during a db push or reset.
enabled = true
# Specifies an ordered list of schema files that describe your database.
# Supports glob patterns relative to supabase directory: "./schemas/*.sql"
schema_paths = []

[db.seed]
# If enabled, seeds the database after migrations during a db reset.
enabled = true
# Specifies an ordered list of seed files to load during db reset.
# Supports glob patterns relative to supabase directory: "./seeds/*.sql"
sql_paths = ["./seed.sql"]

[db.network_restrictions]
# Enable management of network restrictions.
enabled = false
# List of IPv4 CIDR blocks allowed to connect to the database.
# Defaults to allow all IPv4 connections. Set empty array to block all IPs.
allowed_cidrs = ["0.0.0.0/0"]
# List of IPv6 CIDR blocks allowed to connect to the database.
# Defaults to allow all IPv6 connections. Set empty array to block all IPs.
allowed_cidrs_v6 = ["::/0"]

[realtime]
enabled = true
# Bind realtime via either IPv4 or IPv6. (default: IPv4)
# ip_version = "IPv6"
# The maximum length in bytes of HTTP request headers. (default: 4096)
# max_header_length = 4096

[studio]
enabled = true
# Port to use for Supabase Studio.
port = 54323
# External URL of the API server that frontend connects to.
api_url = "http://127.0.0.1"
# OpenAI API Key to use for Supabase AI in the Supabase Studio.
openai_api_key = "env(OPENAI_API_KEY)"

# Email testing server. Emails sent with the local dev setup are not actually sent - rather, they
# are monitored, and you can view the emails that would have been sent from the web interface.
[inbucket]
enabled = true
# Port to use for the email testing server web interface.
port = 54324
# Uncomment to expose additional ports for testing user applications that send emails.
# smtp_port = 54325
# pop3_port = 54326
# admin_email = "admin@email.com"
# sender_name = "Admin"

[storage]
enabled = true
# The maximum file size allowed (e.g. "5MB", "500KB").
file_size_limit = "50MiB"

[storage.buckets.documents]
public = false
file_size_limit = "10MiB"
allowed_mime_types = [
  "application/pdf",
  "application/vnd.openxmlformats-officedocument.wordprocessingml.document",
  "text/plain",
  "text/markdown"
]

# Allow connections via S3 compatible clients
[storage.s3_protocol]
enabled = true

# Image transformation API is available to Supabase Pro plan.
# [storage.image_transformation]
# enabled = true

# Store analytical data in S3 for running ETL jobs over Iceberg Catalog
# This feature is only available on the hosted platform.
[storage.analytics]
enabled = false
max_namespaces = 5
max_tables = 10
max_catalogs = 2

# Analytics Buckets is available to Supabase Pro plan.
# [storage.analytics.buckets.my-warehouse]

# Store vector embeddings in S3 for large and durable datasets
# This feature is only available on the hosted platform.
[storage.vector]
enabled = false
max_buckets = 10
max_indexes = 5

# Vector Buckets is available to Supabase Pro plan.
# [storage.vector.buckets.documents-openai]

[auth]
enabled = true
# The base URL of your website. Used as an allow-list for redirects and for constructing URLs used
# in emails.
site_url = "http://127.0.0.1:3000"
# A list of *exact* URLs that auth providers are permitted to redirect to post authentication.
additional_redirect_urls = ["https://127.0.0.1:3000"]
# How long tokens are valid for, in seconds. Defaults to 3600 (1 hour), maximum 604,800 (1 week).
jwt_expiry = 3600
# JWT issuer URL. If not set, defaults to the local API URL (http://127.0.0.1:<port>/auth/v1).
# jwt_issuer = ""
# Path to JWT signing key. DO NOT commit your signing keys file to git.
# signing_keys_path = "./signing_keys.json"
# If disabled, the refresh token will never expire.
enable_refresh_token_rotation = true
# Allows refresh tokens to be reused after expiry, up to the specified interval in seconds.
# Requires enable_refresh_token_rotation = true.
refresh_token_reuse_interval = 10
# Allow/disallow new user signups to your project.
enable_signup = true
# Allow/disallow anonymous sign-ins to your project.
enable_anonymous_sign_ins = false
# Allow/disallow testing manual linking of accounts
enable_manual_linking = false
# Passwords shorter than this value will be rejected as weak. Minimum 6, recommended 8 or more.
minimum_password_length = 6
# Passwords that do not meet the following requirements will be rejected as weak. Supported values
# are: `letters_digits`, `lower_upper_letters_digits`, `lower_upper_letters_digits_symbols`
password_requirements = ""

[auth.rate_limit]
# Number of emails that can be sent per hour. Requires auth.email.smtp to be enabled.
email_sent = 2
# Number of SMS messages that can be sent per hour. Requires auth.sms to be enabled.
sms_sent = 30
# Number of anonymous sign-ins that can be made per hour per IP address. Requires enable_anonymous_sign_ins = true.
anonymous_users = 30
# Number of sessions that can be refreshed in a 5 minute interval per IP address.
token_refresh = 150
# Number of sign up and sign-in requests that can be made in a 5 minute interval per IP address (excludes anonymous users).
sign_in_sign_ups = 30
# Number of OTP / Magic link verifications that can be made in a 5 minute interval per IP address.
token_verifications = 30
# Number of Web3 logins that can be made in a 5 minute interval per IP address.
web3 = 30

# Configure one of the supported captcha providers: `hcaptcha`, `turnstile`.
# [auth.captcha]
# enabled = true
# provider = "hcaptcha"
# secret = ""

[auth.email]
# Allow/disallow new user signups via email to your project.
enable_signup = true
# If enabled, a user will be required to confirm any email change on both the old, and new email
# addresses. If disabled, only the new email is required to confirm.
double_confirm_changes = true
# If enabled, users need to confirm their email address before signing in.
enable_confirmations = false
# If enabled, users will need to reauthenticate or have logged in recently to change their password.
secure_password_change = false
# Controls the minimum amount of time that must pass before sending another signup confirmation or password reset email.
max_frequency = "1s"
# Number of characters used in the email OTP.
otp_length = 6
# Number of seconds before the email OTP expires (defaults to 1 hour).
otp_expiry = 3600

# Use a production-ready SMTP server
# [auth.email.smtp]
# enabled = true
# host = "smtp.sendgrid.net"
# port = 587
# user = "apikey"
# pass = "env(SENDGRID_API_KEY)"
# admin_email = "admin@email.com"
# sender_name = "Admin"

# Uncomment to customize email template
# [auth.email.template.invite]
# subject = "You have been invited"
# content_path = "./supabase/templates/invite.html"

# Uncomment to customize notification email template
# [auth.email.notification.password_changed]
# enabled = true
# subject = "Your password has been changed"
# content_path = "./templates/password_changed_notification.html"

[auth.sms]
# Allow/disallow new user signups via SMS to your project.
enable_signup = false
# If enabled, users need to confirm their phone number before signing in.
enable_confirmations = false
# Template for sending OTP to users
template = "Your code is {{ .Code }}"
# Controls the minimum amount of time that must pass before sending another sms otp.
max_frequency = "5s"

# Use pre-defined map of phone number to OTP for testing.
# [auth.sms.test_otp]
# 4152127777 = "123456"

# Configure logged in session timeouts.
# [auth.sessions]
# Force log out after the specified duration.
# timebox = "24h"
# Force log out if the user has been inactive longer than the specified duration.
# inactivity_timeout = "8h"

# This hook runs before a new user is created and allows developers to reject the request based on the incoming user object.
# [auth.hook.before_user_created]
# enabled = true
# uri = "pg-functions://postgres/auth/before-user-created-hook"

# This hook runs before a token is issued and allows you to add additional claims based on the authentication method used.
# [auth.hook.custom_access_token]
# enabled = true
# uri = "pg-functions://<database>/<schema>/<hook_name>"

# Configure one of the supported SMS providers: `twilio`, `twilio_verify`, `messagebird`, `textlocal`, `vonage`.
[auth.sms.twilio]
enabled = false
account_sid = ""
message_service_sid = ""
# DO NOT commit your Twilio auth token to git. Use environment variable substitution instead:
auth_token = "env(SUPABASE_AUTH_SMS_TWILIO_AUTH_TOKEN)"

# Multi-factor-authentication is available to Supabase Pro plan.
[auth.mfa]
# Control how many MFA factors can be enrolled at once per user.
max_enrolled_factors = 10

# Control MFA via App Authenticator (TOTP)
[auth.mfa.totp]
enroll_enabled = false
verify_enabled = false

# Configure MFA via Phone Messaging
[auth.mfa.phone]
enroll_enabled = false
verify_enabled = false
otp_length = 6
template = "Your code is {{ .Code }}"
max_frequency = "5s"

# Configure MFA via WebAuthn
# [auth.mfa.web_authn]
# enroll_enabled = true
# verify_enabled = true

# Use an external OAuth provider. The full list of providers are: `apple`, `azure`, `bitbucket`,
# `discord`, `facebook`, `github`, `gitlab`, `google`, `keycloak`, `linkedin_oidc`, `notion`, `twitch`,
# `twitter`, `slack`, `spotify`, `workos`, `zoom`.
[auth.external.apple]
enabled = false
client_id = ""
# DO NOT commit your OAuth provider secret to git. Use environment variable substitution instead:
secret = "env(SUPABASE_AUTH_EXTERNAL_APPLE_SECRET)"
# Overrides the default auth redirectUrl.
redirect_uri = ""
# Overrides the default auth provider URL. Used to support self-hosted gitlab, single-tenant Azure,
# or any other third-party OIDC providers.
url = ""
# If enabled, the nonce check will be skipped. Required for local sign in with Google auth.
skip_nonce_check = false
# If enabled, it will allow the user to successfully authenticate when the provider does not return an email address.
email_optional = false

# Allow Solana wallet holders to sign in to your project via the Sign in with Solana (SIWS, EIP-4361) standard.
# You can configure "web3" rate limit in the [auth.rate_limit] section and set up [auth.captcha] if self-hosting.
[auth.web3.solana]
enabled = false

# Use Firebase Auth as a third-party provider alongside Supabase Auth.
[auth.third_party.firebase]
enabled = false
# project_id = "my-firebase-project"

# Use Auth0 as a third-party provider alongside Supabase Auth.
[auth.third_party.auth0]
enabled = false
# tenant = "my-auth0-tenant"
# tenant_region = "us"

# Use AWS Cognito (Amplify) as a third-party provider alongside Supabase Auth.
[auth.third_party.aws_cognito]
enabled = false
# user_pool_id = "my-user-pool-id"
# user_pool_region = "us-east-1"

# Use Clerk as a third-party provider alongside Supabase Auth.
[auth.third_party.clerk]
enabled = false
# Obtain from https://clerk.com/setup/supabase
# domain = "example.clerk.accounts.dev"

# OAuth server configuration
[auth.oauth_server]
# Enable OAuth server functionality
enabled = false
# Path for OAuth consent flow UI
authorization_url_path = "/oauth/consent"
# Allow dynamic client registration
allow_dynamic_registration = false

[edge_runtime]
enabled = true
# Supported request policies: `oneshot`, `per_worker`.
# `per_worker` (default)  enables hot reload during local development.
# `oneshot`  fallback mode if hot reload causes issues (e.g. in large repos or with symlinks).
policy = "per_worker"
# Port to attach the Chrome inspector for debugging edge functions.
inspector_port = 8083
# The Deno major version to use.
deno_version = 2

# [edge_runtime.secrets]
# secret_key = "env(SECRET_VALUE)"

[analytics]
enabled = true
port = 54327
# Configure one of the supported backends: `postgres`, `bigquery`.
backend = "postgres"

# Experimental features may be deprecated any time
[experimental]
# Configures Postgres storage engine to use OrioleDB (S3)
orioledb_version = ""
# Configures S3 bucket URL, eg. <bucket_name>.s3-<region>.amazonaws.com
s3_host = "env(S3_HOST)"
# Configures S3 bucket region, eg. us-east-1
s3_region = "env(S3_REGION)"
# Configures AWS_ACCESS_KEY_ID for S3 bucket
s3_access_key = "env(S3_ACCESS_KEY)"
# Configures AWS_SECRET_ACCESS_KEY for S3 bucket
s3_secret_key = "env(S3_SECRET_KEY)"
</file>

<file path="packages/db/tsconfig.json">
{
  "extends": "@xquery/config/tsconfig.base.json",
  "compilerOptions": {
    "declaration": true,
    "declarationMap": true,
    "sourceMap": true,
    "outDir": "dist",
    "composite": true,
    "strictNullChecks": true
  }
}
</file>

<file path="apps/server/tsdown.config.ts">
import { defineConfig } from "tsdown";

export default defineConfig({
  entry: "./src/index.ts",
  format: "esm",
  outDir: "./dist",
  clean: true,
  noExternal: [/.*/],
  external: ["bun:*"],
});
</file>

<file path="apps/web/src/components/files/file-upload-form.tsx">
import { useForm } from "@tanstack/react-form";
import { useMutation } from "@tanstack/react-query";
import { FileText, Upload, X } from "lucide-react";
import { useRef, useState } from "react";
import { toast } from "sonner";
import { Button } from "@/components/ui/button";
import { Card, CardContent, CardHeader, CardTitle } from "@/components/ui/card";
import { Input } from "@/components/ui/input";
import { Label } from "@/components/ui/label";
import { cn } from "@/lib/utils";
import { queryClient, trpcClient } from "@/utils/trpc";

const ALLOWED_TYPES = [
  "application/pdf",
  "application/vnd.openxmlformats-officedocument.wordprocessingml.document",
  "text/plain",
  "text/markdown",
];

const MAX_SIZE = 10 * 1024 * 1024;

const ALLOWED_EXTENSIONS = ".pdf,.docx,.txt,.md";

function formatFileSize(bytes: number) {
  if (bytes < 1024) {
    return `${bytes} B`;
  }
  if (bytes < 1024 * 1024) {
    return `${(bytes / 1024).toFixed(1)} KB`;
  }
  return `${(bytes / (1024 * 1024)).toFixed(1)} MB`;
}

function validateFile(file: File): string | null {
  if (!ALLOWED_TYPES.includes(file.type)) {
    return "Invalid file type. Allowed: PDF, DOCX, TXT, MD";
  }
  if (file.size > MAX_SIZE) {
    return "File too large. Maximum size: 10 MB";
  }
  return null;
}

type UploadPhase = "idle" | "uploading" | "syncing";

export function FileUploadForm({ onSuccess }: { onSuccess?: () => void }) {
  const fileInputRef = useRef<HTMLInputElement>(null);
  const [selectedFile, setSelectedFile] = useState<File | null>(null);
  const [isDragActive, setIsDragActive] = useState(false);
  const [uploadPhase, setUploadPhase] = useState<UploadPhase>("idle");

  const uploadMutation = useMutation({
    mutationFn: async ({
      file,
      customName,
    }: {
      file: File;
      customName: string;
    }) => {
      setUploadPhase("uploading");

      const uploadUrlResult = await trpcClient.files.createUploadUrl.mutate({
        filename: file.name,
        mimeType: file.type as
          | "application/pdf"
          | "application/vnd.openxmlformats-officedocument.wordprocessingml.document"
          | "text/plain"
          | "text/markdown",
        size: file.size,
      });

      const response = await fetch(uploadUrlResult.uploadUrl, {
        method: "PUT",
        headers: {
          "Content-Type": file.type,
        },
        body: file,
      });

      if (!response.ok) {
        throw new Error("Upload failed");
      }

      setUploadPhase("syncing");

      await trpcClient.files.confirmUpload.mutate({
        fileId: uploadUrlResult.fileId,
        name: customName || undefined,
      });

      return { fileId: uploadUrlResult.fileId };
    },
    onSuccess: () => {
      toast.success("File uploaded and ready for chat");
      setSelectedFile(null);
      setUploadPhase("idle");
      if (fileInputRef.current) {
        fileInputRef.current.value = "";
      }
      queryClient.invalidateQueries({ queryKey: [["files", "list"]] });
      onSuccess?.();
    },
    onError: (error) => {
      setUploadPhase("idle");
      toast.error(error.message || "Upload failed");
    },
  });

  const form = useForm({
    defaultValues: {
      customName: "",
    },
    onSubmit: async ({ value }) => {
      if (!selectedFile) {
        toast.error("Please select a file");
        return;
      }
      await uploadMutation.mutateAsync({
        file: selectedFile,
        customName: value.customName,
      });
    },
  });

  function handleFile(file: File) {
    const error = validateFile(file);
    if (error) {
      toast.error(error);
      return;
    }
    setSelectedFile(file);
    form.setFieldValue("customName", file.name.replace(/\.[^.]+$/, ""));
  }

  function handleFileSelect(event: React.ChangeEvent<HTMLInputElement>) {
    const file = event.target.files?.[0];
    if (file) {
      handleFile(file);
    }
  }

  function handleDragEnter(event: React.DragEvent) {
    event.preventDefault();
    event.stopPropagation();
    setIsDragActive(true);
  }

  function handleDragLeave(event: React.DragEvent) {
    event.preventDefault();
    event.stopPropagation();
    setIsDragActive(false);
  }

  function handleDragOver(event: React.DragEvent) {
    event.preventDefault();
    event.stopPropagation();
  }

  function handleDrop(event: React.DragEvent) {
    event.preventDefault();
    event.stopPropagation();
    setIsDragActive(false);

    const file = event.dataTransfer.files[0];
    if (file) {
      handleFile(file);
    }
  }

  function clearSelectedFile() {
    setSelectedFile(null);
    if (fileInputRef.current) {
      fileInputRef.current.value = "";
    }
  }

  function openFilePicker() {
    fileInputRef.current?.click();
  }

  return (
    <Card>
      <CardHeader>
        <CardTitle className="flex items-center gap-2">
          <Upload className="h-5 w-5" />
          Upload Document
        </CardTitle>
      </CardHeader>
      <CardContent>
        <form
          className="space-y-4"
          onSubmit={(e) => {
            e.preventDefault();
            e.stopPropagation();
            form.handleSubmit();
          }}
        >
          {/* Hidden file input */}
          <input
            accept={ALLOWED_EXTENSIONS}
            className="hidden"
            disabled={uploadMutation.isPending}
            onChange={handleFileSelect}
            ref={fileInputRef}
            type="file"
          />

          {/* Dropzone */}
          {!selectedFile && (
            <button
              className={cn(
                "flex w-full cursor-pointer flex-col items-center justify-center rounded-lg border-2 border-dashed p-8 transition-colors",
                isDragActive
                  ? "border-primary bg-primary/5"
                  : "border-muted-foreground/25 hover:border-primary/50 hover:bg-muted/50"
              )}
              disabled={uploadMutation.isPending}
              onClick={openFilePicker}
              onDragEnter={handleDragEnter}
              onDragLeave={handleDragLeave}
              onDragOver={handleDragOver}
              onDrop={handleDrop}
              type="button"
            >
              <Upload
                className={cn(
                  "mb-4 h-10 w-10",
                  isDragActive ? "text-primary" : "text-muted-foreground"
                )}
              />
              <p className="mb-1 font-medium text-sm">
                {isDragActive ? "Drop file here" : "Drag & drop your file here"}
              </p>
              <p className="text-muted-foreground text-sm">
                or click to browse
              </p>
              <p className="mt-2 text-muted-foreground text-xs">
                PDF, DOCX, TXT, MD (max 10 MB)
              </p>
            </button>
          )}

          {/* Selected file preview */}
          {selectedFile && (
            <div className="flex items-center justify-between rounded-md border bg-muted/50 p-3">
              <div className="flex items-center gap-2">
                <FileText className="h-4 w-4 text-muted-foreground" />
                <div>
                  <p className="font-medium text-sm">{selectedFile.name}</p>
                  <p className="text-muted-foreground text-xs">
                    {formatFileSize(selectedFile.size)}
                  </p>
                </div>
              </div>
              <Button
                disabled={uploadMutation.isPending}
                onClick={clearSelectedFile}
                size="sm"
                type="button"
                variant="ghost"
              >
                <X className="h-4 w-4" />
              </Button>
            </div>
          )}

          {/* Custom name input */}
          {selectedFile && (
            <form.Field name="customName">
              {(field) => (
                <div className="space-y-2">
                  <Label htmlFor="customName">Display Name (optional)</Label>
                  <Input
                    disabled={uploadMutation.isPending}
                    id="customName"
                    onChange={(e) => field.handleChange(e.target.value)}
                    placeholder="Enter a custom name for this file"
                    value={field.state.value}
                  />
                </div>
              )}
            </form.Field>
          )}

          <Button
            className="w-full"
            disabled={!selectedFile || uploadMutation.isPending}
            type="submit"
          >
            {uploadPhase === "uploading"
              ? "Uploading..."
              : uploadPhase === "syncing"
                ? "Preparing for AI..."
                : "Upload File"}
          </Button>
        </form>
      </CardContent>
    </Card>
  );
}
</file>

<file path="apps/web/src/components/sidebar.tsx">
import { Link, useRouterState } from "@tanstack/react-router";
import { FileText, Home, Menu, MessageSquare, X } from "lucide-react";
import { useState } from "react";
import { cn } from "@/lib/utils";
import { KeyboardShortcutsTrigger } from "./keyboard-shortcuts-dialog";
import { ModeToggle } from "./mode-toggle";
import { Button } from "./ui/button";
import UserMenu from "./user-menu";

const baseNavItems = [
  { to: "/dashboard", label: "Dashboard", icon: Home },
  { to: "/files", label: "Files", icon: FileText },
] as const;

function SidebarContent({ onNavigate }: { onNavigate?: () => void }) {
  const routerState = useRouterState();
  const currentPath = routerState.location.pathname;
  const isOnChatPage = currentPath.startsWith("/chat");

  return (
    <>
      <div className="flex h-14 items-center border-b px-4">
        <Link
          className="flex items-center gap-2 font-semibold"
          onClick={onNavigate}
          to="/dashboard"
        >
          <span className="font-bold text-xl">XQuery</span>
        </Link>
      </div>

      <nav className="flex-1 space-y-1 p-4">
        {baseNavItems.map(({ to, label, icon: Icon }) => {
          const isActive = currentPath.startsWith(to);

          return (
            <Link
              className={cn(
                "flex items-center gap-3 rounded-lg px-3 py-2 text-sm transition-colors",
                isActive
                  ? "bg-primary text-primary-foreground"
                  : "text-muted-foreground hover:bg-accent hover:text-accent-foreground"
              )}
              key={to}
              onClick={onNavigate}
              to={to}
            >
              <Icon className="h-4 w-4" />
              {label}
            </Link>
          );
        })}
        {isOnChatPage && (
          <div
            className={cn(
              "flex items-center gap-3 rounded-lg px-3 py-2 text-sm",
              "bg-primary text-primary-foreground"
            )}
          >
            <MessageSquare className="h-4 w-4" />
            Chat
          </div>
        )}
      </nav>

      <div className="px-4 pb-2">
        <KeyboardShortcutsTrigger />
      </div>

      <div className="border-t p-4">
        <div className="flex items-center justify-between">
          <UserMenu />
          <ModeToggle />
        </div>
      </div>
    </>
  );
}

export function Sidebar() {
  return (
    <aside className="hidden h-full w-64 flex-col border-r bg-card md:flex">
      <SidebarContent />
    </aside>
  );
}

export function MobileHeader() {
  const [isOpen, setIsOpen] = useState(false);

  return (
    <>
      <header className="flex h-14 items-center justify-between border-b bg-card px-4 md:hidden">
        <Link className="flex items-center gap-2 font-semibold" to="/dashboard">
          <span className="font-bold text-xl">XQuery</span>
        </Link>
        <Button onClick={() => setIsOpen(true)} size="icon" variant="ghost">
          <Menu className="h-5 w-5" />
        </Button>
      </header>

      {isOpen && (
        <>
          <button
            aria-label="Close menu"
            className="fixed inset-0 z-40 cursor-default border-none bg-black/50 md:hidden"
            onClick={() => setIsOpen(false)}
            type="button"
          />
          <aside className="fixed inset-y-0 left-0 z-50 flex w-64 flex-col bg-card shadow-lg md:hidden">
            <div className="absolute top-3 right-3">
              <Button
                onClick={() => setIsOpen(false)}
                size="icon"
                variant="ghost"
              >
                <X className="h-5 w-5" />
              </Button>
            </div>
            <SidebarContent onNavigate={() => setIsOpen(false)} />
          </aside>
        </>
      )}
    </>
  );
}
</file>

<file path="apps/web/src/components/sign-in-form.tsx">
import { useForm } from "@tanstack/react-form";
import { useNavigate } from "@tanstack/react-router";
import { Eye, EyeOff, Lock, Mail } from "lucide-react";
import { useState } from "react";
import { toast } from "sonner";
import z from "zod";
import { authClient } from "@/lib/auth-client";
import Loader from "./loader";
import { ModeToggle } from "./mode-toggle";
import { Button } from "./ui/button";
import {
  Card,
  CardContent,
  CardDescription,
  CardHeader,
  CardTitle,
} from "./ui/card";
import { Input } from "./ui/input";
import { Label } from "./ui/label";

export default function SignInForm({
  onSwitchToSignUp,
}: {
  onSwitchToSignUp: () => void;
}) {
  const navigate = useNavigate({
    from: "/",
  });
  const { isPending } = authClient.useSession();
  const [showPassword, setShowPassword] = useState(false);

  const form = useForm({
    defaultValues: {
      email: "",
      password: "",
    },
    onSubmit: async ({ value }) => {
      await authClient.signIn.email(
        {
          email: value.email,
          password: value.password,
        },
        {
          onSuccess: () => {
            navigate({
              to: "/dashboard",
            });
            toast.success("Sign in successful");
          },
          onError: (error) => {
            toast.error(error.error.message || error.error.statusText);
          },
        }
      );
    },
    validators: {
      onSubmit: z.object({
        email: z.email("Invalid email address"),
        password: z.string().min(8, "Password must be at least 8 characters"),
      }),
    },
  });

  if (isPending) {
    return <Loader />;
  }

  return (
    <div className="relative flex min-h-screen items-center justify-center bg-background p-4">
      <div className="absolute top-4 right-4">
        <ModeToggle />
      </div>
      <Card className="w-full max-w-md border-border bg-card">
        <CardHeader className="text-center">
          <div className="mb-2 font-bold text-2xl text-foreground">XQuery</div>
          <CardTitle className="text-foreground text-xl">
            Welcome Back
          </CardTitle>
          <CardDescription className="text-muted-foreground">
            Enter your credentials to sign in to your account
          </CardDescription>
        </CardHeader>
        <CardContent>
          <form
            className="space-y-4"
            onSubmit={(e) => {
              e.preventDefault();
              e.stopPropagation();
              form.handleSubmit();
            }}
          >
            <form.Field name="email">
              {(field) => (
                <div className="space-y-2">
                  <Label htmlFor={field.name}>Email</Label>
                  <div className="relative">
                    <Mail className="-translate-y-1/2 absolute top-1/2 left-3 h-4 w-4 text-muted-foreground" />
                    <Input
                      className="bg-background pl-10 text-foreground"
                      id={field.name}
                      name={field.name}
                      onBlur={field.handleBlur}
                      onChange={(e) => field.handleChange(e.target.value)}
                      placeholder="you@example.com"
                      type="email"
                      value={field.state.value}
                    />
                  </div>
                  {field.state.meta.errors.map((error) => (
                    <p
                      className="text-destructive text-sm"
                      key={error?.message}
                    >
                      {error?.message}
                    </p>
                  ))}
                </div>
              )}
            </form.Field>

            <form.Field name="password">
              {(field) => (
                <div className="space-y-2">
                  <Label htmlFor={field.name}>Password</Label>
                  <div className="relative">
                    <Lock className="-translate-y-1/2 absolute top-1/2 left-3 h-4 w-4 text-muted-foreground" />
                    <Input
                      className="bg-background pr-10 pl-10 text-foreground"
                      id={field.name}
                      name={field.name}
                      onBlur={field.handleBlur}
                      onChange={(e) => field.handleChange(e.target.value)}
                      placeholder="Enter your password"
                      type={showPassword ? "text" : "password"}
                      value={field.state.value}
                    />
                    <button
                      className="-translate-y-1/2 absolute top-1/2 right-3 text-muted-foreground hover:text-foreground"
                      onClick={() => setShowPassword(!showPassword)}
                      type="button"
                    >
                      {showPassword ? (
                        <EyeOff className="h-4 w-4" />
                      ) : (
                        <Eye className="h-4 w-4" />
                      )}
                    </button>
                  </div>
                  {field.state.meta.errors.map((error) => (
                    <p
                      className="text-destructive text-sm"
                      key={error?.message}
                    >
                      {error?.message}
                    </p>
                  ))}
                </div>
              )}
            </form.Field>

            <form.Subscribe>
              {(state) => (
                <Button
                  className="w-full"
                  disabled={!state.canSubmit || state.isSubmitting}
                  type="submit"
                >
                  {state.isSubmitting ? "Signing in..." : "Sign In"}
                </Button>
              )}
            </form.Subscribe>
          </form>

          <div className="mt-6 text-center">
            <p className="text-muted-foreground text-sm">
              Need an account?{" "}
              <Button
                className="h-auto p-0 font-semibold"
                onClick={onSwitchToSignUp}
                variant="link"
              >
                Sign Up
              </Button>
            </p>
          </div>
        </CardContent>
      </Card>
    </div>
  );
}
</file>

<file path="apps/web/src/components/sign-up-form.tsx">
import { useForm } from "@tanstack/react-form";
import { useNavigate } from "@tanstack/react-router";
import {
  CheckCircle2,
  Eye,
  EyeOff,
  KeyRound,
  Lock,
  Mail,
  User,
  XCircle,
} from "lucide-react";
import { useState } from "react";
import { toast } from "sonner";
import z from "zod";
import { authClient } from "@/lib/auth-client";
import { cn } from "@/lib/utils";
import Loader from "./loader";
import { ModeToggle } from "./mode-toggle";
import { Button } from "./ui/button";
import {
  Card,
  CardContent,
  CardDescription,
  CardHeader,
  CardTitle,
} from "./ui/card";
import { Input } from "./ui/input";
import { Label } from "./ui/label";

const nameSchema = z.string().min(2, "Name must be at least 2 characters");
const emailSchema = z.string().email("Invalid email address");
const passwordSchema = z
  .string()
  .min(8, "Password must be at least 8 characters");
const invitationCodeSchema = z.string().min(1, "Invitation code is required");

export default function SignUpForm({
  onSwitchToSignIn,
}: {
  onSwitchToSignIn: () => void;
}) {
  const navigate = useNavigate({
    from: "/",
  });
  const { isPending } = authClient.useSession();
  const [showPassword, setShowPassword] = useState(false);

  const form = useForm({
    defaultValues: {
      email: "",
      password: "",
      name: "",
      invitationCode: "",
    },
    onSubmit: async ({ value }) => {
      await authClient.signUp.email(
        {
          email: value.email,
          password: value.password,
          name: value.name,
        },
        {
          onSuccess: () => {
            navigate({
              to: "/dashboard",
            });
            toast.success("Sign up successful");
          },
          onError: (error) => {
            toast.error(error.error.message || error.error.statusText);
          },
          body: {
            invitationCode: value.invitationCode,
          },
        }
      );
    },
  });

  if (isPending) {
    return <Loader />;
  }

  return (
    <div className="relative flex min-h-screen items-center justify-center bg-background p-4">
      <div className="absolute top-4 right-4">
        <ModeToggle />
      </div>
      <Card className="w-full max-w-md border-border bg-card">
        <CardHeader className="text-center">
          <div className="mb-2 font-bold text-2xl text-foreground">XQuery</div>
          <CardTitle className="text-foreground text-xl">
            Create Account
          </CardTitle>
          <CardDescription className="text-muted-foreground">
            Enter your details to create a new account
          </CardDescription>
        </CardHeader>
        <CardContent>
          <form
            className="space-y-4"
            onSubmit={(e) => {
              e.preventDefault();
              e.stopPropagation();
              form.handleSubmit();
            }}
          >
            <form.Field
              name="name"
              validators={{
                onChange: nameSchema,
              }}
            >
              {(field) => {
                const hasValue = field.state.value.length > 0;
                const hasErrors = field.state.meta.errors.length > 0;
                const isValid = hasValue && !hasErrors;
                return (
                  <div className="space-y-2">
                    <Label htmlFor={field.name}>Name</Label>
                    <div className="relative">
                      <User className="-translate-y-1/2 absolute top-1/2 left-3 h-4 w-4 text-muted-foreground" />
                      <Input
                        className={cn(
                          "bg-background pr-10 pl-10 text-foreground",
                          hasErrors && "border-destructive",
                          isValid && "border-primary"
                        )}
                        id={field.name}
                        name={field.name}
                        onBlur={field.handleBlur}
                        onChange={(e) => field.handleChange(e.target.value)}
                        placeholder="John Doe"
                        value={field.state.value}
                      />
                      {hasValue && (
                        <div className="-translate-y-1/2 absolute top-1/2 right-3">
                          {isValid ? (
                            <CheckCircle2 className="h-4 w-4 text-primary" />
                          ) : (
                            <XCircle className="h-4 w-4 text-destructive" />
                          )}
                        </div>
                      )}
                    </div>
                    {field.state.meta.errors.map((error) => (
                      <p
                        className="text-destructive text-sm"
                        key={error?.message}
                      >
                        {error?.message}
                      </p>
                    ))}
                  </div>
                );
              }}
            </form.Field>

            <form.Field
              name="email"
              validators={{
                onChange: emailSchema,
              }}
            >
              {(field) => {
                const hasValue = field.state.value.length > 0;
                const hasErrors = field.state.meta.errors.length > 0;
                const isValid = hasValue && !hasErrors;
                return (
                  <div className="space-y-2">
                    <Label htmlFor={field.name}>Email</Label>
                    <div className="relative">
                      <Mail className="-translate-y-1/2 absolute top-1/2 left-3 h-4 w-4 text-muted-foreground" />
                      <Input
                        className={cn(
                          "bg-background pr-10 pl-10 text-foreground",
                          hasErrors && "border-destructive",
                          isValid && "border-primary"
                        )}
                        id={field.name}
                        name={field.name}
                        onBlur={field.handleBlur}
                        onChange={(e) => field.handleChange(e.target.value)}
                        placeholder="you@example.com"
                        type="email"
                        value={field.state.value}
                      />
                      {hasValue && (
                        <div className="-translate-y-1/2 absolute top-1/2 right-3">
                          {isValid ? (
                            <CheckCircle2 className="h-4 w-4 text-primary" />
                          ) : (
                            <XCircle className="h-4 w-4 text-destructive" />
                          )}
                        </div>
                      )}
                    </div>
                    {field.state.meta.errors.map((error) => (
                      <p
                        className="text-destructive text-sm"
                        key={error?.message}
                      >
                        {error?.message}
                      </p>
                    ))}
                  </div>
                );
              }}
            </form.Field>

            <form.Field
              name="password"
              validators={{
                onChange: passwordSchema,
              }}
            >
              {(field) => {
                const hasValue = field.state.value.length > 0;
                const hasErrors = field.state.meta.errors.length > 0;
                const isValid = hasValue && !hasErrors;
                return (
                  <div className="space-y-2">
                    <Label htmlFor={field.name}>Password</Label>
                    <div className="relative">
                      <Lock className="-translate-y-1/2 absolute top-1/2 left-3 h-4 w-4 text-muted-foreground" />
                      <Input
                        className={cn(
                          "bg-background pr-16 pl-10 text-foreground",
                          hasErrors && "border-destructive",
                          isValid && "border-primary"
                        )}
                        id={field.name}
                        name={field.name}
                        onBlur={field.handleBlur}
                        onChange={(e) => field.handleChange(e.target.value)}
                        placeholder="Enter your password"
                        type={showPassword ? "text" : "password"}
                        value={field.state.value}
                      />
                      <div className="-translate-y-1/2 absolute top-1/2 right-3 flex items-center gap-1">
                        {hasValue &&
                          (isValid ? (
                            <CheckCircle2 className="h-4 w-4 text-primary" />
                          ) : (
                            <XCircle className="h-4 w-4 text-destructive" />
                          ))}
                        <button
                          className="text-muted-foreground hover:text-foreground"
                          onClick={() => setShowPassword(!showPassword)}
                          type="button"
                        >
                          {showPassword ? (
                            <EyeOff className="h-4 w-4" />
                          ) : (
                            <Eye className="h-4 w-4" />
                          )}
                        </button>
                      </div>
                    </div>
                    {field.state.meta.errors.map((error) => (
                      <p
                        className="text-destructive text-sm"
                        key={error?.message}
                      >
                        {error?.message}
                      </p>
                    ))}
                  </div>
                );
              }}
            </form.Field>

            <form.Field
              name="invitationCode"
              validators={{
                onChange: invitationCodeSchema,
              }}
            >
              {(field) => {
                const hasValue = field.state.value.length > 0;
                const hasErrors = field.state.meta.errors.length > 0;
                const isValid = hasValue && !hasErrors;
                return (
                  <div className="space-y-2">
                    <Label htmlFor={field.name}>Invitation Code</Label>
                    <div className="relative">
                      <KeyRound className="-translate-y-1/2 absolute top-1/2 left-3 h-4 w-4 text-muted-foreground" />
                      <Input
                        className={cn(
                          "bg-background pr-10 pl-10 text-foreground",
                          hasErrors && "border-destructive",
                          isValid && "border-primary"
                        )}
                        id={field.name}
                        name={field.name}
                        onBlur={field.handleBlur}
                        onChange={(e) => field.handleChange(e.target.value)}
                        placeholder="Enter your invitation code"
                        value={field.state.value}
                      />
                      {hasValue && (
                        <div className="-translate-y-1/2 absolute top-1/2 right-3">
                          {isValid ? (
                            <CheckCircle2 className="h-4 w-4 text-primary" />
                          ) : (
                            <XCircle className="h-4 w-4 text-destructive" />
                          )}
                        </div>
                      )}
                    </div>
                    {field.state.meta.errors.map((error) => (
                      <p
                        className="text-destructive text-sm"
                        key={error?.message}
                      >
                        {error?.message}
                      </p>
                    ))}
                  </div>
                );
              }}
            </form.Field>

            <form.Subscribe>
              {(state) => (
                <Button
                  className="w-full"
                  disabled={!state.canSubmit || state.isSubmitting}
                  type="submit"
                >
                  {state.isSubmitting
                    ? "Creating account..."
                    : "Create Account"}
                </Button>
              )}
            </form.Subscribe>
          </form>

          <div className="mt-6 text-center">
            <p className="text-muted-foreground text-sm">
              Already have an account?{" "}
              <Button
                className="h-auto p-0 font-semibold"
                onClick={onSwitchToSignIn}
                variant="link"
              >
                Sign In
              </Button>
            </p>
          </div>
        </CardContent>
      </Card>
    </div>
  );
}
</file>

<file path="apps/web/src/main.tsx">
import { QueryClientProvider } from "@tanstack/react-query";
import { createRouter, RouterProvider } from "@tanstack/react-router";
import ReactDOM from "react-dom/client";
import Loader from "./components/loader";
import { routeTree } from "./routeTree.gen";
import { queryClient, trpc } from "./utils/trpc";

const router = createRouter({
  routeTree,
  defaultPreload: "intent",
  defaultPendingComponent: () => <Loader />,
  context: { trpc, queryClient },
  Wrap({ children }: { children: React.ReactNode }) {
    return (
      <QueryClientProvider client={queryClient}>{children}</QueryClientProvider>
    );
  },
});

declare module "@tanstack/react-router" {
  // biome-ignore lint/style/useConsistentTypeDefinitions: interface required for module augmentation
  interface Register {
    router: typeof router;
  }
}

const rootElement = document.getElementById("app");

if (!rootElement) {
  throw new Error("Root element not found");
}

if (!rootElement.innerHTML) {
  const root = ReactDOM.createRoot(rootElement);
  root.render(<RouterProvider router={router} />);
}
</file>

<file path="apps/web/src/routes/index.tsx">
import { createFileRoute, redirect } from "@tanstack/react-router";

export const Route = createFileRoute("/")({
  beforeLoad: () => {
    redirect({
      to: "/dashboard",
      throw: true,
    });
  },
});
</file>

<file path="apps/web/src/routes/login.tsx">
import { createFileRoute } from "@tanstack/react-router";
import { AnimatePresence, motion } from "framer-motion";
import { useState } from "react";
import SignInForm from "@/components/sign-in-form";
import SignUpForm from "@/components/sign-up-form";
import { useReducedMotion } from "@/hooks/use-reduced-motion";
import { scaleFadeVariants } from "@/lib/motion";

export const Route = createFileRoute("/login")({
  component: RouteComponent,
});

function RouteComponent() {
  const [showSignIn, setShowSignIn] = useState(false);
  const prefersReducedMotion = useReducedMotion();

  return (
    <AnimatePresence mode="wait">
      {showSignIn ? (
        <motion.div
          animate="visible"
          exit={prefersReducedMotion ? undefined : "exit"}
          initial={prefersReducedMotion ? false : "hidden"}
          key="signin"
          variants={prefersReducedMotion ? undefined : scaleFadeVariants}
        >
          <SignInForm onSwitchToSignUp={() => setShowSignIn(false)} />
        </motion.div>
      ) : (
        <motion.div
          animate="visible"
          exit={prefersReducedMotion ? undefined : "exit"}
          initial={prefersReducedMotion ? false : "hidden"}
          key="signup"
          variants={prefersReducedMotion ? undefined : scaleFadeVariants}
        >
          <SignUpForm onSwitchToSignIn={() => setShowSignIn(true)} />
        </motion.div>
      )}
    </AnimatePresence>
  );
}
</file>

<file path="apps/web/src/routeTree.gen.ts">
/* eslint-disable */

// @ts-nocheck

// noinspection JSUnusedGlobalSymbols

// This file was automatically generated by TanStack Router.
// You should NOT make any changes in this file as it will be overwritten.
// Additionally, you should also exclude this file from your linter and/or formatter to prevent it from being checked or modified.

import { Route as rootRouteImport } from './routes/__root'
import { Route as LoginRouteImport } from './routes/login'
import { Route as FilesRouteImport } from './routes/files'
import { Route as DashboardRouteImport } from './routes/dashboard'
import { Route as ChatRouteImport } from './routes/chat'
import { Route as IndexRouteImport } from './routes/index'
import { Route as ChatChatIdRouteImport } from './routes/chat.$chatId'

const LoginRoute = LoginRouteImport.update({
  id: '/login',
  path: '/login',
  getParentRoute: () => rootRouteImport,
} as any)
const FilesRoute = FilesRouteImport.update({
  id: '/files',
  path: '/files',
  getParentRoute: () => rootRouteImport,
} as any)
const DashboardRoute = DashboardRouteImport.update({
  id: '/dashboard',
  path: '/dashboard',
  getParentRoute: () => rootRouteImport,
} as any)
const ChatRoute = ChatRouteImport.update({
  id: '/chat',
  path: '/chat',
  getParentRoute: () => rootRouteImport,
} as any)
const IndexRoute = IndexRouteImport.update({
  id: '/',
  path: '/',
  getParentRoute: () => rootRouteImport,
} as any)
const ChatChatIdRoute = ChatChatIdRouteImport.update({
  id: '/$chatId',
  path: '/$chatId',
  getParentRoute: () => ChatRoute,
} as any)

export interface FileRoutesByFullPath {
  '/': typeof IndexRoute
  '/chat': typeof ChatRouteWithChildren
  '/dashboard': typeof DashboardRoute
  '/files': typeof FilesRoute
  '/login': typeof LoginRoute
  '/chat/$chatId': typeof ChatChatIdRoute
}
export interface FileRoutesByTo {
  '/': typeof IndexRoute
  '/chat': typeof ChatRouteWithChildren
  '/dashboard': typeof DashboardRoute
  '/files': typeof FilesRoute
  '/login': typeof LoginRoute
  '/chat/$chatId': typeof ChatChatIdRoute
}
export interface FileRoutesById {
  __root__: typeof rootRouteImport
  '/': typeof IndexRoute
  '/chat': typeof ChatRouteWithChildren
  '/dashboard': typeof DashboardRoute
  '/files': typeof FilesRoute
  '/login': typeof LoginRoute
  '/chat/$chatId': typeof ChatChatIdRoute
}
export interface FileRouteTypes {
  fileRoutesByFullPath: FileRoutesByFullPath
  fullPaths:
    | '/'
    | '/chat'
    | '/dashboard'
    | '/files'
    | '/login'
    | '/chat/$chatId'
  fileRoutesByTo: FileRoutesByTo
  to: '/' | '/chat' | '/dashboard' | '/files' | '/login' | '/chat/$chatId'
  id:
    | '__root__'
    | '/'
    | '/chat'
    | '/dashboard'
    | '/files'
    | '/login'
    | '/chat/$chatId'
  fileRoutesById: FileRoutesById
}
export interface RootRouteChildren {
  IndexRoute: typeof IndexRoute
  ChatRoute: typeof ChatRouteWithChildren
  DashboardRoute: typeof DashboardRoute
  FilesRoute: typeof FilesRoute
  LoginRoute: typeof LoginRoute
}

declare module '@tanstack/react-router' {
  interface FileRoutesByPath {
    '/login': {
      id: '/login'
      path: '/login'
      fullPath: '/login'
      preLoaderRoute: typeof LoginRouteImport
      parentRoute: typeof rootRouteImport
    }
    '/files': {
      id: '/files'
      path: '/files'
      fullPath: '/files'
      preLoaderRoute: typeof FilesRouteImport
      parentRoute: typeof rootRouteImport
    }
    '/dashboard': {
      id: '/dashboard'
      path: '/dashboard'
      fullPath: '/dashboard'
      preLoaderRoute: typeof DashboardRouteImport
      parentRoute: typeof rootRouteImport
    }
    '/chat': {
      id: '/chat'
      path: '/chat'
      fullPath: '/chat'
      preLoaderRoute: typeof ChatRouteImport
      parentRoute: typeof rootRouteImport
    }
    '/': {
      id: '/'
      path: '/'
      fullPath: '/'
      preLoaderRoute: typeof IndexRouteImport
      parentRoute: typeof rootRouteImport
    }
    '/chat/$chatId': {
      id: '/chat/$chatId'
      path: '/$chatId'
      fullPath: '/chat/$chatId'
      preLoaderRoute: typeof ChatChatIdRouteImport
      parentRoute: typeof ChatRoute
    }
  }
}

interface ChatRouteChildren {
  ChatChatIdRoute: typeof ChatChatIdRoute
}

const ChatRouteChildren: ChatRouteChildren = {
  ChatChatIdRoute: ChatChatIdRoute,
}

const ChatRouteWithChildren = ChatRoute._addFileChildren(ChatRouteChildren)

const rootRouteChildren: RootRouteChildren = {
  IndexRoute: IndexRoute,
  ChatRoute: ChatRouteWithChildren,
  DashboardRoute: DashboardRoute,
  FilesRoute: FilesRoute,
  LoginRoute: LoginRoute,
}
export const routeTree = rootRouteImport
  ._addFileChildren(rootRouteChildren)
  ._addFileTypes<FileRouteTypes>()
</file>

<file path="apps/web/src/utils/trpc.ts">
import { QueryCache, QueryClient } from "@tanstack/react-query";
import { createTRPCClient, httpBatchLink } from "@trpc/client";
import { createTRPCOptionsProxy } from "@trpc/tanstack-react-query";
import type { AppRouter } from "@xquery/api/routers/index";
import { toast } from "sonner";

export const queryClient = new QueryClient({
  defaultOptions: {
    queries: {
      staleTime: 1000 * 30,
      refetchOnWindowFocus: false,
    },
  },
  queryCache: new QueryCache({
    onError: (error) => {
      toast.error(error.message, {
        action: {
          label: "retry",
          onClick: () => {
            queryClient.invalidateQueries();
          },
        },
      });
    },
  }),
});

export const trpcClient = createTRPCClient<AppRouter>({
  links: [
    httpBatchLink({
      url: `${import.meta.env.VITE_SERVER_URL}/trpc`,
      fetch(_url, options) {
        return fetch(_url, {
          ...options,
          credentials: "include",
        });
      },
    }),
  ],
});

export const trpc = createTRPCOptionsProxy<AppRouter>({
  client: trpcClient,
  queryClient,
});
</file>

<file path="biome.json">
{
  "$schema": "./node_modules/@biomejs/biome/configuration_schema.json",
  "files": {
    "ignoreUnknown": false,
    "includes": [
      "**",
      "!**/.next",
      "!**/dist",
      "!**/.turbo",
      "!**/dev-dist",
      "!**/.zed",
      "!**/.vscode",
      "!**/routeTree.gen.ts",
      "!**/src-tauri",
      "!**/.nuxt",
      "!bts.jsonc",
      "!**/.expo",
      "!**/.wrangler",
      "!**/.alchemy",
      "!**/.svelte-kit",
      "!**/wrangler.jsonc",
      "!**/.source"
    ]
  },
  "extends": ["ultracite/core", "ultracite/react"],
  "linter": {
    "rules": {
      "performance": {
        "useTopLevelRegex": "off",
        "noBarrelFile": "off",
        "noNamespaceImport": "off"
      },
      "style": {
        "noNestedTernary": "off",
        "useFilenamingConvention": "off"
      },
      "nursery": {
        "noLeakedRender": "off"
      }
    }
  }
}
</file>

<file path="packages/api/package.json">
{
  "name": "@xquery/api",
  "exports": {
    ".": {
      "default": "./src/index.ts"
    },
    "./*": {
      "default": "./src/*.ts"
    }
  },
  "type": "module",
  "scripts": {
    "test": "vitest",
    "test:run": "vitest run",
    "test:coverage": "vitest run --coverage"
  },
  "devDependencies": {
    "@xquery/config": "workspace:*",
    "vitest": "^4.0.15"
  },
  "peerDependencies": {
    "typescript": "^5"
  },
  "dependencies": {
    "@trpc/client": "catalog:",
    "@trpc/server": "catalog:",
    "@xquery/auth": "workspace:*",
    "@xquery/db": "workspace:*",
    "dotenv": "catalog:",
    "hono": "catalog:",
    "openai": "^6.10.0",
    "zod": "catalog:"
  }
}
</file>

<file path="packages/api/src/lib/openai.ts">
import { OpenAI } from "openai";

const apiKey = process.env.OPENAI_API_KEY;

if (!apiKey) {
  console.warn(
    "OPENAI_API_KEY not set. OpenAI features will not be available."
  );
}

export const openai = new OpenAI({
  apiKey: apiKey || "",
});

export const ASSISTANT_MODEL = "gpt-4o-mini";

export const ASSISTANT_INSTRUCTIONS = `You are a helpful assistant that answers questions about documents.
When the user asks a question, search through the attached file(s) to find relevant information.
Provide clear, accurate answers based on the document content.
If the information is not found in the documents, say so clearly.`;

let cachedAssistantId: string | null = null;

export async function getOrCreateAssistant(): Promise<string> {
  if (cachedAssistantId) {
    return cachedAssistantId;
  }

  const existingAssistantId = process.env.OPENAI_ASSISTANT_ID;
  if (existingAssistantId) {
    cachedAssistantId = existingAssistantId;
    return existingAssistantId;
  }

  const assistant = await openai.beta.assistants.create({
    name: "Document Assistant",
    instructions: ASSISTANT_INSTRUCTIONS,
    model: ASSISTANT_MODEL,
    tools: [{ type: "file_search" }],
  });

  cachedAssistantId = assistant.id;
  console.log(`Created new assistant: ${assistant.id}`);
  console.log("Set OPENAI_ASSISTANT_ID env var to reuse this assistant.");

  return assistant.id;
}
</file>

<file path="packages/api/src/routers/index.ts">
import { protectedProcedure, publicProcedure, router } from "../index";
import { chatRouter } from "./chat";
import { filesRouter } from "./files";

export const appRouter = router({
  healthCheck: publicProcedure.query(() => "OK"),
  privateData: protectedProcedure.query(({ ctx }) => ({
    message: "This is private",
    user: ctx.session.user,
  })),
  files: filesRouter,
  chat: chatRouter,
});
export type AppRouter = typeof appRouter;
</file>

<file path="packages/db/src/index.ts">
import { drizzle } from "drizzle-orm/node-postgres";

export const db = drizzle(process.env.DATABASE_URL || "");

export { and, asc, count, desc, eq, ilike, or } from "drizzle-orm";
export * from "./schema/auth";
export * from "./schema/chat";
export * from "./schema/files";
export * from "./supabase";
</file>

<file path=".claude/settings.local.json">
{
  "permissions": {
    "allow": [
      "Bash(tree:*)",
      "Bash(cat:*)",
      "Bash(npx ultracite check)",
      "Bash(bun run:*)",
      "Bash(npx ultracite:*)",
      "Bash(dir:*)",
      "Bash(findstr:*)",
      "WebSearch",
      "WebFetch(domain:hono.dev)",
      "Bash(bun add:*)",
      "Bash(bun x ultracite:*)"
    ]
  }
}
</file>

<file path="apps/server/src/index.ts">
import "dotenv/config";
import { trpcServer } from "@hono/trpc-server";
import { createContext } from "@xquery/api/context";
import { appRouter } from "@xquery/api/routers/index";
import { streamQuestion } from "@xquery/api/streaming";
import { auth } from "@xquery/auth";
import { ensureDocumentsBucketExists } from "@xquery/db";
import { Hono } from "hono";
import { cors } from "hono/cors";
import { logger } from "hono/logger";
import { streamSSE } from "hono/streaming";

// Ensure storage bucket exists on startup
ensureDocumentsBucketExists().catch(console.error);

const app = new Hono();

app.use(logger());
app.use(
  "/*",
  cors({
    origin: process.env.CORS_ORIGIN || "",
    allowMethods: ["GET", "POST", "OPTIONS"],
    allowHeaders: ["Content-Type", "Authorization"],
    credentials: true,
  })
);

app.on(["POST", "GET"], "/api/auth/*", (c) => auth.handler(c.req.raw));

app.use(
  "/trpc/*",
  trpcServer({
    router: appRouter,
    createContext: (_opts, context) => createContext({ context }),
  })
);

app.get("/", (c) => c.text("OK"));

app.post("/api/chat/stream", async (c) => {
  const session = await auth.api.getSession({ headers: c.req.raw.headers });
  if (!session) {
    return c.json({ error: "Unauthorized" }, 401);
  }

  const body = await c.req.json<{ chatId: string; question: string }>();
  if (!(body.chatId && body.question)) {
    return c.json({ error: "Missing chatId or question" }, 400);
  }

  return streamSSE(c, async (stream) => {
    let clientDisconnected = false;

    const writeEvent = async (event: string, data: unknown) => {
      if (clientDisconnected) {
        return;
      }
      try {
        await stream.writeSSE({
          event,
          data: JSON.stringify(data),
        });
      } catch {
        clientDisconnected = true;
      }
    };

    try {
      for await (const event of streamQuestion({
        userId: session.user.id,
        chatId: body.chatId,
        question: body.question,
      })) {
        await writeEvent(event.type, event.data);
      }
    } catch (error) {
      await writeEvent("error", {
        message: error instanceof Error ? error.message : "Unknown error",
      });
    }
  });
});

export default app;
</file>

<file path="apps/web/index.html">
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="icon" href="/favicon.ico">
    <title>XQuery</title>
  </head>

  <body>
    <div id="app"></div>
    <script type="module" src="/src/main.tsx"></script>
  </body>
</html>
</file>

<file path="apps/web/src/components/files/file-upload-dialog.tsx">
import { useMutation } from "@tanstack/react-query";
import {
  AlertCircle,
  CheckCircle,
  FileText,
  Loader2,
  Upload,
  X,
} from "lucide-react";
import { useRef, useState } from "react";
import { toast } from "sonner";
import { Button } from "@/components/ui/button";
import {
  Dialog,
  DialogContent,
  DialogDescription,
  DialogFooter,
  DialogHeader,
  DialogTitle,
  DialogTrigger,
} from "@/components/ui/dialog";
import { cn } from "@/lib/utils";
import { queryClient, trpcClient } from "@/utils/trpc";

const ALLOWED_TYPES = [
  "application/pdf",
  "application/vnd.openxmlformats-officedocument.wordprocessingml.document",
  "text/plain",
  "text/markdown",
];

const MAX_SIZE = 10 * 1024 * 1024;

const ALLOWED_EXTENSIONS = ".pdf,.docx,.txt,.md";

type FileStatus = "pending" | "uploading" | "done" | "error";

type SelectedFile = {
  id: string;
  file: File;
  status: FileStatus;
  error?: string;
};

function formatFileSize(bytes: number) {
  if (bytes < 1024) {
    return `${bytes} B`;
  }
  if (bytes < 1024 * 1024) {
    return `${(bytes / 1024).toFixed(1)} KB`;
  }
  return `${(bytes / (1024 * 1024)).toFixed(1)} MB`;
}

function validateFile(file: File): string | null {
  if (!ALLOWED_TYPES.includes(file.type)) {
    return "Invalid file type. Allowed: PDF, DOCX, TXT, MD";
  }
  if (file.size > MAX_SIZE) {
    return "File too large. Maximum size: 10 MB";
  }
  return null;
}

function getFileTypeIcon(_mimeType: string) {
  return <FileText className="h-4 w-4 text-muted-foreground" />;
}

function FileStatusIcon({ status }: { status: FileStatus }) {
  switch (status) {
    case "uploading":
      return <Loader2 className="h-4 w-4 animate-spin text-primary" />;
    case "done":
      return <CheckCircle className="h-4 w-4 text-green-500" />;
    case "error":
      return <AlertCircle className="h-4 w-4 text-destructive" />;
    default:
      return null;
  }
}

type FileUploadDialogProps = {
  onSuccess?: () => void;
  open?: boolean;
  onOpenChange?: (open: boolean) => void;
};

export function FileUploadDialog({
  onSuccess,
  open: controlledOpen,
  onOpenChange,
}: FileUploadDialogProps) {
  const fileInputRef = useRef<HTMLInputElement>(null);
  const [internalOpen, setInternalOpen] = useState(false);
  const [selectedFiles, setSelectedFiles] = useState<SelectedFile[]>([]);
  const [isDragActive, setIsDragActive] = useState(false);
  const [isUploading, setIsUploading] = useState(false);

  const open = controlledOpen ?? internalOpen;
  const setOpen = onOpenChange ?? setInternalOpen;

  const uploadMutation = useMutation({
    mutationFn: async (file: File) => {
      const uploadUrlResult = await trpcClient.files.createUploadUrl.mutate({
        filename: file.name,
        mimeType: file.type as
          | "application/pdf"
          | "application/vnd.openxmlformats-officedocument.wordprocessingml.document"
          | "text/plain"
          | "text/markdown",
        size: file.size,
      });

      const response = await fetch(uploadUrlResult.uploadUrl, {
        method: "PUT",
        headers: {
          "Content-Type": file.type,
        },
        body: file,
      });

      if (!response.ok) {
        throw new Error("Upload failed");
      }

      await trpcClient.files.confirmUpload.mutate({
        fileId: uploadUrlResult.fileId,
      });

      return { fileId: uploadUrlResult.fileId };
    },
  });

  function handleFiles(files: FileList | File[]) {
    const fileArray = Array.from(files);
    const newSelectedFiles: SelectedFile[] = [];

    for (const file of fileArray) {
      const error = validateFile(file);
      if (error) {
        toast.error(`${file.name}: ${error}`);
        continue;
      }

      const existingFile = selectedFiles.find(
        (sf) => sf.file.name === file.name && sf.file.size === file.size
      );
      if (existingFile) {
        continue;
      }

      newSelectedFiles.push({
        id: crypto.randomUUID(),
        file,
        status: "pending",
      });
    }

    if (newSelectedFiles.length > 0) {
      setSelectedFiles((prev) => [...prev, ...newSelectedFiles]);
    }
  }

  function handleFileSelect(event: React.ChangeEvent<HTMLInputElement>) {
    const files = event.target.files;
    if (files) {
      handleFiles(files);
    }
    if (fileInputRef.current) {
      fileInputRef.current.value = "";
    }
  }

  function handleDragEnter(event: React.DragEvent) {
    event.preventDefault();
    event.stopPropagation();
    setIsDragActive(true);
  }

  function handleDragLeave(event: React.DragEvent) {
    event.preventDefault();
    event.stopPropagation();
    setIsDragActive(false);
  }

  function handleDragOver(event: React.DragEvent) {
    event.preventDefault();
    event.stopPropagation();
  }

  function handleDrop(event: React.DragEvent) {
    event.preventDefault();
    event.stopPropagation();
    setIsDragActive(false);

    const files = event.dataTransfer.files;
    if (files.length > 0) {
      handleFiles(files);
    }
  }

  function removeFile(id: string) {
    setSelectedFiles((prev) => prev.filter((f) => f.id !== id));
  }

  function openFilePicker() {
    fileInputRef.current?.click();
  }

  function updateFileStatus(
    fileId: string,
    status: FileStatus,
    error?: string
  ) {
    setSelectedFiles((prev) =>
      prev.map((f) => (f.id === fileId ? { ...f, status, error } : f))
    );
  }

  async function uploadSingleFile(selectedFile: SelectedFile) {
    updateFileStatus(selectedFile.id, "uploading");
    try {
      await uploadMutation.mutateAsync(selectedFile.file);
      updateFileStatus(selectedFile.id, "done");
      return true;
    } catch (error) {
      const errorMessage =
        error instanceof Error ? error.message : "Upload failed";
      updateFileStatus(selectedFile.id, "error", errorMessage);
      return false;
    }
  }

  function showUploadResult(successCount: number, errorCount: number) {
    if (successCount > 0 && errorCount === 0) {
      const plural = successCount > 1 ? "s" : "";
      toast.success(`${successCount} file${plural} uploaded successfully`);
      setSelectedFiles([]);
      setOpen(false);
      onSuccess?.();
    } else if (successCount > 0) {
      toast.warning(
        `${successCount} uploaded, ${errorCount} failed. Check errors and retry.`
      );
    } else {
      toast.error("All uploads failed");
    }
  }

  async function uploadAllFiles() {
    if (selectedFiles.length === 0 || isUploading) {
      return;
    }

    setIsUploading(true);
    let successCount = 0;
    let errorCount = 0;

    for (const selectedFile of selectedFiles) {
      if (selectedFile.status === "done") {
        successCount += 1;
        continue;
      }

      const success = await uploadSingleFile(selectedFile);
      if (success) {
        successCount += 1;
      } else {
        errorCount += 1;
      }
    }

    setIsUploading(false);
    queryClient.invalidateQueries({ queryKey: [["files", "list"]] });
    showUploadResult(successCount, errorCount);
  }

  function handleOpenChange(newOpen: boolean) {
    if (!newOpen && isUploading) {
      return;
    }
    if (!newOpen) {
      setSelectedFiles([]);
    }
    setOpen(newOpen);
  }

  const pendingCount = selectedFiles.filter(
    (f) => f.status === "pending" || f.status === "error"
  ).length;

  return (
    <Dialog onOpenChange={handleOpenChange} open={open}>
      <DialogTrigger asChild>
        <Button className="w-full sm:w-auto">
          <Upload className="mr-2 h-4 w-4" />
          Upload Documents
        </Button>
      </DialogTrigger>
      <DialogContent>
        <DialogHeader>
          <DialogTitle>Upload Documents</DialogTitle>
          <DialogDescription>
            Upload PDF, DOCX, TXT, or MD files (max 10 MB each)
          </DialogDescription>
        </DialogHeader>

        <input
          accept={ALLOWED_EXTENSIONS}
          className="hidden"
          disabled={isUploading}
          multiple
          onChange={handleFileSelect}
          ref={fileInputRef}
          type="file"
        />

        <button
          className={cn(
            "flex w-full cursor-pointer flex-col items-center justify-center rounded-lg border-2 border-dashed p-6 transition-colors",
            isDragActive
              ? "border-primary bg-primary/5"
              : "border-muted-foreground/25 hover:border-primary/50 hover:bg-muted/50",
            isUploading && "cursor-not-allowed opacity-50"
          )}
          disabled={isUploading}
          onClick={openFilePicker}
          onDragEnter={handleDragEnter}
          onDragLeave={handleDragLeave}
          onDragOver={handleDragOver}
          onDrop={handleDrop}
          type="button"
        >
          <Upload
            className={cn(
              "mb-3 h-8 w-8",
              isDragActive ? "text-primary" : "text-muted-foreground"
            )}
          />
          <p className="mb-1 font-medium text-sm">
            {isDragActive ? "Drop files here" : "Drag & drop files here"}
          </p>
          <p className="text-muted-foreground text-sm">or click to browse</p>
        </button>

        {selectedFiles.length > 0 && (
          <div className="space-y-2">
            <p className="font-medium text-sm">
              Selected Files ({selectedFiles.length}):
            </p>
            <div className="max-h-48 space-y-2 overflow-y-auto overflow-x-hidden rounded-md border p-2">
              {selectedFiles.map((sf) => (
                <div
                  className={cn(
                    "flex items-center gap-2 overflow-hidden rounded-md bg-muted/50 p-2 text-sm",
                    sf.status === "error" && "bg-destructive/10"
                  )}
                  key={sf.id}
                >
                  <div className="flex min-w-0 flex-1 items-center gap-2 overflow-hidden">
                    <div className="shrink-0">
                      {getFileTypeIcon(sf.file.type)}
                    </div>
                    <div className="min-w-0 flex-1 overflow-hidden">
                      <p className="truncate font-medium text-sm">
                        {sf.file.name}
                      </p>
                      <p className="text-muted-foreground text-xs">
                        {formatFileSize(sf.file.size)}
                        {sf.error && (
                          <span className="ml-2 text-destructive">
                            {sf.error}
                          </span>
                        )}
                      </p>
                    </div>
                  </div>
                  <div className="flex shrink-0 items-center gap-2">
                    <FileStatusIcon status={sf.status} />
                    {sf.status !== "uploading" && sf.status !== "done" && (
                      <Button
                        className="h-6 w-6 p-0"
                        disabled={isUploading}
                        onClick={() => removeFile(sf.id)}
                        size="sm"
                        type="button"
                        variant="ghost"
                      >
                        <X className="h-3 w-3" />
                      </Button>
                    )}
                  </div>
                </div>
              ))}
            </div>
          </div>
        )}

        <DialogFooter>
          <Button
            disabled={isUploading}
            onClick={() => handleOpenChange(false)}
            type="button"
            variant="outline"
          >
            Cancel
          </Button>
          <Button
            disabled={pendingCount === 0 || isUploading}
            onClick={uploadAllFiles}
            type="button"
          >
            {isUploading ? (
              <>
                <Loader2 className="mr-2 h-4 w-4 animate-spin" />
                Uploading...
              </>
            ) : (
              `Upload ${pendingCount > 0 ? pendingCount : ""} File${pendingCount !== 1 ? "s" : ""}`
            )}
          </Button>
        </DialogFooter>
      </DialogContent>
    </Dialog>
  );
}
</file>

<file path="apps/web/src/components/user-menu.tsx">
import { Link, useNavigate } from "@tanstack/react-router";
import { LogOut, User } from "lucide-react";
import {
  DropdownMenu,
  DropdownMenuContent,
  DropdownMenuItem,
  DropdownMenuLabel,
  DropdownMenuSeparator,
  DropdownMenuTrigger,
} from "@/components/ui/dropdown-menu";
import { authClient } from "@/lib/auth-client";
import { Button } from "./ui/button";
import { Skeleton } from "./ui/skeleton";

export default function UserMenu() {
  const navigate = useNavigate();
  const { data: session, isPending } = authClient.useSession();

  const handleLogout = () => {
    authClient.signOut({
      fetchOptions: {
        onSuccess: () => {
          navigate({
            to: "/",
          });
        },
      },
    });
  };

  if (isPending) {
    return <Skeleton className="h-9 w-24" />;
  }

  if (!session?.user) {
    return (
      <Button asChild variant="outline">
        <Link to="/login">Sign In</Link>
      </Button>
    );
  }

  return (
    <DropdownMenu>
      <DropdownMenuTrigger asChild>
        <Button className="gap-2" variant="outline">
          <User className="h-4 w-4" />
          {session.user.name}
        </Button>
      </DropdownMenuTrigger>
      <DropdownMenuContent align="end" className="w-56 bg-card">
        <DropdownMenuLabel className="font-normal">
          <div className="flex flex-col space-y-1">
            <p className="font-medium text-sm leading-none">
              {session.user.name}
            </p>
            <p className="text-muted-foreground text-xs leading-none">
              {session.user.email}
            </p>
          </div>
        </DropdownMenuLabel>
        <DropdownMenuSeparator />
        <DropdownMenuItem
          className="gap-2 text-destructive focus:bg-destructive/10 focus:text-destructive"
          onClick={handleLogout}
        >
          <LogOut className="h-4 w-4" />
          <span>Sign Out</span>
        </DropdownMenuItem>
      </DropdownMenuContent>
    </DropdownMenu>
  );
}
</file>

<file path="apps/web/src/routes/chat.$chatId.tsx">
import { useQuery } from "@tanstack/react-query";
import { createFileRoute } from "@tanstack/react-router";
import { AnimatePresence, motion } from "framer-motion";
import { Bot, Download, FileText, Loader2, Send, User } from "lucide-react";
import { useCallback, useEffect, useMemo, useRef, useState } from "react";
import Markdown from "react-markdown";
import remarkGfm from "remark-gfm";
import { toast } from "sonner";
import { Button } from "@/components/ui/button";
import { Input } from "@/components/ui/input";
import { Skeleton } from "@/components/ui/skeleton";
import { useHotkeys } from "@/hooks/use-hotkeys";
import { useReducedMotion } from "@/hooks/use-reduced-motion";
import {
  fadeVariants,
  slideFromLeftVariants,
  slideFromRightVariants,
} from "@/lib/motion";
import { cn } from "@/lib/utils";
import { queryClient, trpc } from "@/utils/trpc";

export const Route = createFileRoute("/chat/$chatId")({
  component: ChatPage,
});

function getMessageVariants(
  role: "user" | "assistant",
  prefersReducedMotion: boolean
) {
  if (prefersReducedMotion) {
    return;
  }
  return role === "user" ? slideFromRightVariants : slideFromLeftVariants;
}

// biome-ignore lint/complexity/noExcessiveCognitiveComplexity: chat page has necessary UI complexity for streaming, messages, and animations
function ChatPage() {
  const { chatId } = Route.useParams();
  const prefersReducedMotion = useReducedMotion();
  const [input, setInput] = useState("");
  const [pendingMessage, setPendingMessage] = useState<string | null>(null);
  const [streamingContent, setStreamingContent] = useState<string>("");
  const [statusMessage, setStatusMessage] = useState<string>("");
  const [isStreaming, setIsStreaming] = useState(false);
  const messagesEndRef = useRef<HTMLDivElement>(null);
  const abortControllerRef = useRef<AbortController | null>(null);
  const inputRef = useRef<HTMLInputElement>(null);

  const chatQuery = useQuery({
    ...trpc.chat.get.queryOptions({ chatId }),
    placeholderData: (prev) => prev,
  });

  const messages = chatQuery.data?.messages;

  // biome-ignore lint/correctness/useExhaustiveDependencies: intentionally scroll when messages or streaming content change
  useEffect(() => {
    const timeout = setTimeout(() => {
      messagesEndRef.current?.scrollIntoView({ behavior: "smooth" });
    }, 100);
    return () => clearTimeout(timeout);
  }, [messages, streamingContent]);

  const streamQuestion = useCallback(
    // biome-ignore lint/complexity/noExcessiveCognitiveComplexity: streaming logic requires multiple conditional branches
    async (question: string) => {
      setIsStreaming(true);
      setStreamingContent("");
      setStatusMessage("Connecting...");

      // Optimistically update the chat title if this is the first message
      const isFirstMessage = !chatQuery.data?.title;
      if (isFirstMessage) {
        const optimisticTitle =
          question.length > 30 ? `${question.substring(0, 30)}...` : question;

        // Update chat.get cache for current chat
        const chatGetKey = [
          ["chat", "get"],
          { input: { chatId }, type: "query" },
        ];
        queryClient.setQueryData(chatGetKey, (old: unknown) => {
          if (old && typeof old === "object") {
            return { ...old, title: optimisticTitle };
          }
          return old;
        });

        // Update chat.list cache for sidebar
        const fileId = chatQuery.data?.fileId;
        if (fileId) {
          const chatListKey = [
            ["chat", "list"],
            { input: { fileId }, type: "query" },
          ];
          queryClient.setQueryData(chatListKey, (old: unknown) => {
            if (old && Array.isArray(old)) {
              return old.map((c: { id: string; title: string | null }) =>
                c.id === chatId ? { ...c, title: optimisticTitle } : c
              );
            }
            return old;
          });
        }
      }

      abortControllerRef.current = new AbortController();

      try {
        const response = await fetch(
          `${import.meta.env.VITE_SERVER_URL}/api/chat/stream`,
          {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            credentials: "include",
            body: JSON.stringify({ chatId, question }),
            signal: abortControllerRef.current.signal,
          }
        );

        if (!response.ok) {
          throw new Error("Failed to start stream");
        }

        const reader = response.body?.getReader();
        if (!reader) {
          throw new Error("No response body");
        }

        const decoder = new TextDecoder();
        let buffer = "";
        let accumulatedContent = "";
        let receivedDone = false;

        while (true) {
          const { done, value } = await reader.read();
          if (done) {
            break;
          }

          buffer += decoder.decode(value, { stream: true });
          const lines = buffer.split("\n");
          buffer = lines.pop() || "";

          let currentEvent: string | null = null;
          for (const line of lines) {
            if (line.startsWith("event: ")) {
              currentEvent = line.slice(7);
            } else if (line.startsWith("data: ") && currentEvent) {
              const data = JSON.parse(line.slice(6));

              if (currentEvent === "status") {
                setStatusMessage(data.message);
              } else if (currentEvent === "delta") {
                setStatusMessage("");
                accumulatedContent += data.content;
                setStreamingContent(accumulatedContent);
              } else if (currentEvent === "done") {
                receivedDone = true;
                const userMsgId = data.userMessageId;
                const assistantMsgId = data.assistantMessageId;

                const queryKey = [
                  ["chat", "get"],
                  { input: { chatId }, type: "query" },
                ];

                const existingData = queryClient.getQueryData(queryKey);

                if (existingData && typeof existingData === "object") {
                  const oldData = existingData as {
                    messages?: Array<{
                      id: string;
                      role: string;
                      content: string;
                      createdAt: Date;
                    }>;
                  };
                  queryClient.setQueryData(queryKey, {
                    ...oldData,
                    messages: [
                      ...(oldData.messages || []),
                      {
                        id: userMsgId,
                        role: "user",
                        content: question,
                        createdAt: new Date(),
                      },
                      {
                        id: assistantMsgId,
                        role: "assistant",
                        content: accumulatedContent,
                        createdAt: new Date(),
                      },
                    ],
                  });
                } else {
                  await queryClient.invalidateQueries({ queryKey });
                }

                setPendingMessage(null);
                setStreamingContent("");
                setIsStreaming(false);

                // Invalidate chat list to sync title and updatedAt with server
                queryClient.invalidateQueries({
                  queryKey: [["chat", "list"]],
                });
              } else if (currentEvent === "error") {
                throw new Error(data.message);
              }
              currentEvent = null;
            }
          }
        }

        if (!receivedDone) {
          setPendingMessage(null);
          setStreamingContent("");
          setIsStreaming(false);
          queryClient.invalidateQueries({
            queryKey: [["chat", "get"], { input: { chatId }, type: "query" }],
          });
        }
      } catch (error) {
        if (error instanceof Error && error.name === "AbortError") {
          return;
        }
        setPendingMessage(null);
        setStreamingContent("");
        setIsStreaming(false);
        toast.error(
          error instanceof Error ? error.message : "Failed to get response"
        );
      }
    },
    [chatId, chatQuery.data?.title, chatQuery.data?.fileId]
  );

  const handleSubmit = useCallback(
    (e?: React.FormEvent) => {
      e?.preventDefault();
      const canSubmit = input.trim() && !isStreaming;
      if (!canSubmit) {
        return;
      }

      const question = input.trim();
      setInput("");
      setPendingMessage(question);
      streamQuestion(question);
    },
    [input, isStreaming, streamQuestion]
  );

  const cancelStreaming = useCallback(() => {
    if (isStreaming) {
      abortControllerRef.current?.abort();
      setPendingMessage(null);
      setStreamingContent("");
      setIsStreaming(false);
      toast.info("Cancelled");
    }
  }, [isStreaming]);

  const hotkeys = useMemo(
    () => [
      {
        key: "Enter",
        ctrl: true,
        callback: () => handleSubmit(),
        enabled: !!input.trim() && !isStreaming,
      },
      {
        key: "Escape",
        callback: cancelStreaming,
        enabled: isStreaming,
      },
    ],
    [input, isStreaming, cancelStreaming, handleSubmit]
  );

  useHotkeys(hotkeys);

  const handleExportChat = useCallback(() => {
    if (!messages?.length) {
      return;
    }

    const exportData = messages.map(({ role, content, createdAt }) => ({
      role,
      content,
      createdAt,
    }));

    const title = chatQuery.data?.title;
    const blob = new Blob([JSON.stringify(exportData, null, 2)], {
      type: "application/json",
    });
    const url = URL.createObjectURL(blob);
    const a = document.createElement("a");
    a.href = url;
    a.download = `chat-${title ? title.slice(0, 30).replace(/[^a-z0-9]/gi, "-") : chatId}.json`;
    a.click();
    URL.revokeObjectURL(url);
  }, [messages, chatQuery.data?.title, chatId]);

  useEffect(
    () => () => {
      abortControllerRef.current?.abort();
    },
    []
  );

  const isInitialLoading = chatQuery.isLoading && !chatQuery.data;

  if (isInitialLoading) {
    return (
      <div className="flex h-full flex-col">
        <div className="border-b p-4">
          <Skeleton className="h-6 w-48" />
        </div>
        <div className="flex-1 space-y-4 p-4">
          <Skeleton className="h-16 w-3/4" />
          <Skeleton className="ml-auto h-16 w-2/3" />
          <Skeleton className="h-16 w-3/4" />
        </div>
      </div>
    );
  }

  if (chatQuery.error && !chatQuery.data) {
    return (
      <div className="flex h-full items-center justify-center">
        <div className="text-center">
          <p className="mb-4 text-muted-foreground">Chat not found</p>
        </div>
      </div>
    );
  }

  const chatData = chatQuery.data;
  const displayMessages = messages ?? [];

  return (
    <div className="flex h-full flex-col">
      <div className="flex h-14 items-center gap-4 border-b px-4">
        <div className="min-w-0 flex-1">
          <div className="flex items-center gap-2">
            <FileText className="h-4 w-4 shrink-0 text-muted-foreground" />
            <span className="truncate font-medium">{chatData?.fileName}</span>
          </div>
          {chatData?.title && (
            <p className="truncate text-muted-foreground text-sm">
              {chatData.title}
            </p>
          )}
        </div>
        <Button
          disabled={!messages?.length}
          onClick={handleExportChat}
          size="icon"
          title="Export chat as JSON"
          variant="ghost"
        >
          <Download className="h-4 w-4" />
        </Button>
      </div>

      <div className="flex-1 overflow-y-auto p-4">
        <div className="mx-auto max-w-3xl space-y-4">
          {displayMessages.length === 0 && !isStreaming && (
            <div className="py-12 text-center text-muted-foreground">
              <Bot className="mx-auto mb-4 h-12 w-12 opacity-50" />
              <p>Ask a question about this document</p>
              <p className="text-sm">
                The AI will search through the file to find answers
              </p>
            </div>
          )}

          <AnimatePresence mode="popLayout">
            {displayMessages.map((message) => (
              <motion.div
                animate="visible"
                className={cn(
                  "flex gap-3",
                  message.role === "user" ? "justify-end" : "justify-start"
                )}
                initial={prefersReducedMotion ? false : "hidden"}
                key={message.id}
                layout={!prefersReducedMotion}
                variants={getMessageVariants(
                  message.role,
                  prefersReducedMotion
                )}
              >
                {message.role === "assistant" && (
                  <div className="flex h-8 w-8 shrink-0 items-center justify-center rounded-full bg-primary/10">
                    <Bot className="h-4 w-4 text-primary" />
                  </div>
                )}
                <div
                  className={cn(
                    "max-w-[80%] rounded-lg px-4 py-2",
                    message.role === "user"
                      ? "bg-primary text-primary-foreground"
                      : "bg-muted"
                  )}
                >
                  {message.role === "assistant" ? (
                    <div className="prose prose-sm dark:prose-invert max-w-none">
                      <Markdown remarkPlugins={[remarkGfm]}>
                        {message.content}
                      </Markdown>
                    </div>
                  ) : (
                    <p className="whitespace-pre-wrap text-sm">
                      {message.content}
                    </p>
                  )}
                </div>
                {message.role === "user" && (
                  <div className="flex h-8 w-8 shrink-0 items-center justify-center rounded-full bg-primary">
                    <User className="h-4 w-4 text-primary-foreground" />
                  </div>
                )}
              </motion.div>
            ))}
          </AnimatePresence>

          <AnimatePresence>
            {pendingMessage && (
              <motion.div
                animate="visible"
                className="flex justify-end gap-3"
                exit={prefersReducedMotion ? undefined : { opacity: 0 }}
                initial={prefersReducedMotion ? false : "hidden"}
                variants={
                  prefersReducedMotion ? undefined : slideFromRightVariants
                }
              >
                <div className="max-w-[80%] rounded-lg bg-primary px-4 py-2 text-primary-foreground">
                  <p className="whitespace-pre-wrap text-sm">
                    {pendingMessage}
                  </p>
                </div>
                <div className="flex h-8 w-8 shrink-0 items-center justify-center rounded-full bg-primary">
                  <User className="h-4 w-4 text-primary-foreground" />
                </div>
              </motion.div>
            )}
          </AnimatePresence>

          <AnimatePresence>
            {isStreaming && (
              <motion.div
                animate="visible"
                className="flex gap-3"
                initial={prefersReducedMotion ? false : "hidden"}
                variants={prefersReducedMotion ? undefined : fadeVariants}
              >
                <div className="flex h-8 w-8 shrink-0 items-center justify-center rounded-full bg-primary/10">
                  <Bot className="h-4 w-4 text-primary" />
                </div>
                {streamingContent ? (
                  <div className="max-w-[80%] rounded-lg bg-muted px-4 py-2">
                    <div className="prose prose-sm dark:prose-invert max-w-none">
                      <Markdown remarkPlugins={[remarkGfm]}>
                        {streamingContent}
                      </Markdown>
                    </div>
                  </div>
                ) : (
                  <div className="flex items-center gap-2 rounded-lg bg-muted px-4 py-2">
                    <Loader2 className="h-4 w-4 animate-spin" />
                    <span className="text-muted-foreground text-sm">
                      {statusMessage || "Thinking..."}
                    </span>
                  </div>
                )}
              </motion.div>
            )}
          </AnimatePresence>

          <div ref={messagesEndRef} />
        </div>
      </div>

      <div className="border-t p-4">
        <form className="mx-auto max-w-3xl" onSubmit={handleSubmit}>
          <div className="flex gap-2">
            <Input
              autoFocus
              disabled={isStreaming}
              maxLength={2000}
              onChange={(e) => setInput(e.target.value)}
              placeholder="Ask a question about this document..."
              ref={inputRef}
              value={input}
            />
            <Button
              disabled={!input.trim() || isStreaming}
              size="icon"
              type="submit"
            >
              {isStreaming ? (
                <Loader2 className="h-4 w-4 animate-spin" />
              ) : (
                <Send className="h-4 w-4" />
              )}
            </Button>
          </div>
          <div className="mt-1 text-right text-muted-foreground text-xs">
            {input.length}/2000
          </div>
        </form>
      </div>
    </div>
  );
}
</file>

<file path="packages/api/src/routers/files.ts">
import { TRPCError } from "@trpc/server";
import {
  ALLOWED_MIME_TYPES,
  and,
  DOCUMENTS_BUCKET,
  db,
  desc,
  eq,
  file,
  MAX_FILE_SIZE,
  supabaseAdmin,
} from "@xquery/db";
import { z } from "zod";
import { protectedProcedure, router } from "../index";
import { openai } from "../lib/openai";

type FileRecord = {
  id: string;
  storagePath: string;
  originalFilename: string;
  mimeType: string;
};

async function syncFileToOpenAI(fileRecord: FileRecord): Promise<void> {
  const { data: fileData, error: downloadError } = await supabaseAdmin.storage
    .from(DOCUMENTS_BUCKET)
    .download(fileRecord.storagePath);

  if (downloadError || !fileData) {
    throw new Error("Failed to download file from storage");
  }

  const openaiFile = await openai.files.create({
    file: new File([fileData], fileRecord.originalFilename, {
      type: fileRecord.mimeType,
    }),
    purpose: "assistants",
  });

  await db
    .update(file)
    .set({ openaiFileId: openaiFile.id })
    .where(eq(file.id, fileRecord.id));
}

const mimeTypeSchema = z.enum(ALLOWED_MIME_TYPES);

const createUploadUrlSchema = z.object({
  filename: z.string().min(1).max(255),
  mimeType: mimeTypeSchema,
  size: z.number().int().positive().max(MAX_FILE_SIZE),
});

const confirmUploadSchema = z.object({
  fileId: z.string().uuid(),
  name: z.string().min(1).max(255).optional(),
});

export const filesRouter = router({
  createUploadUrl: protectedProcedure
    .input(createUploadUrlSchema)
    .mutation(async ({ ctx, input }) => {
      const userId = ctx.session.user.id;
      const fileId = crypto.randomUUID();
      const fileExtension = input.filename.split(".").pop() || "";
      const storagePath = `${userId}/${fileId}.${fileExtension}`;

      const { data, error } = await supabaseAdmin.storage
        .from(DOCUMENTS_BUCKET)
        .createSignedUploadUrl(storagePath);

      if (error || !data) {
        throw new TRPCError({
          code: "INTERNAL_SERVER_ERROR",
          message: "Failed to create upload URL",
          cause: error,
        });
      }

      await db.insert(file).values({
        id: fileId,
        userId,
        name: input.filename,
        originalFilename: input.filename,
        mimeType: input.mimeType,
        size: input.size,
        storagePath,
      });

      return {
        fileId,
        uploadUrl: data.signedUrl,
        token: data.token,
        path: storagePath,
      };
    }),

  confirmUpload: protectedProcedure
    .input(confirmUploadSchema)
    .mutation(async ({ ctx, input }) => {
      const userId = ctx.session.user.id;

      const existingFile = await db
        .select()
        .from(file)
        .where(and(eq(file.id, input.fileId), eq(file.userId, userId)))
        .limit(1);

      const fileRecord = existingFile[0];
      if (!fileRecord) {
        throw new TRPCError({
          code: "NOT_FOUND",
          message: "File not found",
        });
      }

      const fileName = fileRecord.storagePath.split("/").pop();

      const { data: storageFiles, error } = await supabaseAdmin.storage
        .from(DOCUMENTS_BUCKET)
        .list(userId, {
          search: fileName,
        });

      if (error || !storageFiles || storageFiles.length === 0) {
        await db.delete(file).where(eq(file.id, input.fileId));
        throw new TRPCError({
          code: "BAD_REQUEST",
          message: "Upload not completed or file not found in storage",
        });
      }

      if (input.name) {
        await db
          .update(file)
          .set({ name: input.name })
          .where(eq(file.id, input.fileId));
      }

      await syncFileToOpenAI(fileRecord);

      return { success: true, fileId: input.fileId };
    }),

  list: protectedProcedure
    .input(
      z
        .object({
          limit: z.number().int().min(1).max(100).default(20),
          offset: z.number().int().min(0).default(0),
        })
        .optional()
    )
    .query(async ({ ctx, input }) => {
      const userId = ctx.session.user.id;
      const limit = input?.limit ?? 20;
      const offset = input?.offset ?? 0;

      const files = await db
        .select({
          id: file.id,
          name: file.name,
          originalFilename: file.originalFilename,
          mimeType: file.mimeType,
          size: file.size,
          createdAt: file.createdAt,
          openaiFileId: file.openaiFileId,
        })
        .from(file)
        .where(eq(file.userId, userId))
        .orderBy(desc(file.createdAt))
        .limit(limit)
        .offset(offset);

      return files;
    }),

  get: protectedProcedure
    .input(z.object({ fileId: z.string().uuid() }))
    .query(async ({ ctx, input }) => {
      const userId = ctx.session.user.id;

      const result = await db
        .select()
        .from(file)
        .where(and(eq(file.id, input.fileId), eq(file.userId, userId)))
        .limit(1);

      const fileRecord = result[0];
      if (!fileRecord) {
        throw new TRPCError({
          code: "NOT_FOUND",
          message: "File not found",
        });
      }

      return fileRecord;
    }),

  getDownloadUrl: protectedProcedure
    .input(z.object({ fileId: z.string().uuid() }))
    .mutation(async ({ ctx, input }) => {
      const userId = ctx.session.user.id;

      const result = await db
        .select({ storagePath: file.storagePath })
        .from(file)
        .where(and(eq(file.id, input.fileId), eq(file.userId, userId)))
        .limit(1);

      const fileRecord = result[0];
      if (!fileRecord) {
        throw new TRPCError({
          code: "NOT_FOUND",
          message: "File not found",
        });
      }

      const { data, error } = await supabaseAdmin.storage
        .from(DOCUMENTS_BUCKET)
        .createSignedUrl(fileRecord.storagePath, 60 * 5);

      if (error || !data) {
        throw new TRPCError({
          code: "INTERNAL_SERVER_ERROR",
          message: "Failed to create download URL",
        });
      }

      return { url: data.signedUrl };
    }),

  delete: protectedProcedure
    .input(z.object({ fileId: z.string().uuid() }))
    .mutation(async ({ ctx, input }) => {
      const userId = ctx.session.user.id;

      const result = await db
        .select({
          storagePath: file.storagePath,
          openaiFileId: file.openaiFileId,
        })
        .from(file)
        .where(and(eq(file.id, input.fileId), eq(file.userId, userId)))
        .limit(1);

      const fileRecord = result[0];
      if (!fileRecord) {
        throw new TRPCError({
          code: "NOT_FOUND",
          message: "File not found",
        });
      }

      const { error: storageError } = await supabaseAdmin.storage
        .from(DOCUMENTS_BUCKET)
        .remove([fileRecord.storagePath]);

      if (storageError) {
        console.error("Storage deletion error:", storageError);
      }

      if (fileRecord.openaiFileId) {
        try {
          await openai.files.delete(fileRecord.openaiFileId);
        } catch (error) {
          console.error("OpenAI file deletion error:", error);
        }
      }

      await db.delete(file).where(eq(file.id, input.fileId));

      return { success: true };
    }),

  rename: protectedProcedure
    .input(
      z.object({
        fileId: z.string().uuid(),
        name: z.string().min(1).max(255),
      })
    )
    .mutation(async ({ ctx, input }) => {
      const userId = ctx.session.user.id;

      const result = await db
        .update(file)
        .set({ name: input.name })
        .where(and(eq(file.id, input.fileId), eq(file.userId, userId)))
        .returning({ id: file.id });

      if (result.length === 0) {
        throw new TRPCError({
          code: "NOT_FOUND",
          message: "File not found",
        });
      }

      return { success: true };
    }),
});
</file>

<file path="packages/auth/src/index.ts">
import { db } from "@xquery/db";
import * as schema from "@xquery/db/schema/auth";
import { betterAuth } from "better-auth";
import { drizzleAdapter } from "better-auth/adapters/drizzle";
import { APIError } from "better-auth/api";

const VALID_INVITATION_CODE = process.env.INVITATION_CODE;

export const auth = betterAuth({
  database: drizzleAdapter(db, {
    provider: "pg",

    schema,
  }),
  trustedOrigins: [process.env.CORS_ORIGIN || ""],
  emailAndPassword: {
    enabled: true,
  },
  advanced: {
    defaultCookieAttributes: {
      sameSite: "none",
      secure: true,
      httpOnly: true,
    },
  },
  databaseHooks: {
    user: {
      create: {
        before: (user, ctx) => {
          const invitationCode = ctx?.body?.invitationCode as
            | string
            | undefined;
          if (invitationCode !== VALID_INVITATION_CODE) {
            throw new APIError("FORBIDDEN", {
              message: "Invalid invitation code",
            });
          }
          return Promise.resolve({ data: user });
        },
      },
    },
  },
});
</file>

<file path="apps/web/src/index.css">
@import "tailwindcss";
@import "tw-animate-css";
@plugin "@tailwindcss/typography";

@custom-variant dark (&:where(.dark, .dark *));

@theme {
  --font-sans:
    "Inter", "Geist", ui-sans-serif, system-ui, sans-serif, "Apple Color Emoji",
    "Segoe UI Emoji", "Segoe UI Symbol", "Noto Color Emoji";
}

html {
  @media (prefers-color-scheme: dark) {
    color-scheme: dark;
  }
}

.dark {
  color-scheme: dark;
}

:root {
  --radius: 0.625rem;
  --background: oklch(1 0 0);
  --foreground: oklch(0.145 0 0);
  --card: oklch(1 0 0);
  --card-foreground: oklch(0.145 0 0);
  --popover: oklch(1 0 0);
  --popover-foreground: oklch(0.145 0 0);
  --primary: oklch(0.205 0 0);
  --primary-foreground: oklch(0.985 0 0);
  --secondary: oklch(0.97 0 0);
  --secondary-foreground: oklch(0.205 0 0);
  --muted: oklch(0.97 0 0);
  --muted-foreground: oklch(0.556 0 0);
  --accent: oklch(0.97 0 0);
  --accent-foreground: oklch(0.205 0 0);
  --destructive: oklch(0.577 0.245 27.325);
  --border: oklch(0.922 0 0);
  --input: oklch(0.922 0 0);
  --ring: oklch(0.708 0 0);
  --chart-1: oklch(0.646 0.222 41.116);
  --chart-2: oklch(0.6 0.118 184.704);
  --chart-3: oklch(0.398 0.07 227.392);
  --chart-4: oklch(0.828 0.189 84.429);
  --chart-5: oklch(0.769 0.188 70.08);
  --sidebar: oklch(0.985 0 0);
  --sidebar-foreground: oklch(0.145 0 0);
  --sidebar-primary: oklch(0.205 0 0);
  --sidebar-primary-foreground: oklch(0.985 0 0);
  --sidebar-accent: oklch(0.97 0 0);
  --sidebar-accent-foreground: oklch(0.205 0 0);
  --sidebar-border: oklch(0.922 0 0);
  --sidebar-ring: oklch(0.708 0 0);
}

.dark {
  --background: oklch(0.145 0 0);
  --foreground: oklch(0.985 0 0);
  --card: oklch(0.205 0 0);
  --card-foreground: oklch(0.985 0 0);
  --popover: oklch(0.205 0 0);
  --popover-foreground: oklch(0.985 0 0);
  --primary: oklch(0.922 0 0);
  --primary-foreground: oklch(0.205 0 0);
  --secondary: oklch(0.269 0 0);
  --secondary-foreground: oklch(0.985 0 0);
  --muted: oklch(0.269 0 0);
  --muted-foreground: oklch(0.708 0 0);
  --accent: oklch(0.269 0 0);
  --accent-foreground: oklch(0.985 0 0);
  --destructive: oklch(0.704 0.191 22.216);
  --border: oklch(1 0 0 / 10%);
  --input: oklch(1 0 0 / 15%);
  --ring: oklch(0.556 0 0);
  --chart-1: oklch(0.488 0.243 264.376);
  --chart-2: oklch(0.696 0.17 162.48);
  --chart-3: oklch(0.769 0.188 70.08);
  --chart-4: oklch(0.627 0.265 303.9);
  --chart-5: oklch(0.645 0.246 16.439);
  --sidebar: oklch(0.205 0 0);
  --sidebar-foreground: oklch(0.985 0 0);
  --sidebar-primary: oklch(0.488 0.243 264.376);
  --sidebar-primary-foreground: oklch(0.985 0 0);
  --sidebar-accent: oklch(0.269 0 0);
  --sidebar-accent-foreground: oklch(0.985 0 0);
  --sidebar-border: oklch(1 0 0 / 10%);
  --sidebar-ring: oklch(0.556 0 0);
}

@theme inline {
  --radius-sm: calc(var(--radius) - 4px);
  --radius-md: calc(var(--radius) - 2px);
  --radius-lg: var(--radius);
  --radius-xl: calc(var(--radius) + 4px);
  --color-background: var(--background);
  --color-foreground: var(--foreground);
  --color-card: var(--card);
  --color-card-foreground: var(--card-foreground);
  --color-popover: var(--popover);
  --color-popover-foreground: var(--popover-foreground);
  --color-primary: var(--primary);
  --color-primary-foreground: var(--primary-foreground);
  --color-secondary: var(--secondary);
  --color-secondary-foreground: var(--secondary-foreground);
  --color-muted: var(--muted);
  --color-muted-foreground: var(--muted-foreground);
  --color-accent: var(--accent);
  --color-accent-foreground: var(--accent-foreground);
  --color-destructive: var(--destructive);
  --color-border: var(--border);
  --color-input: var(--input);
  --color-ring: var(--ring);
  --color-chart-1: var(--chart-1);
  --color-chart-2: var(--chart-2);
  --color-chart-3: var(--chart-3);
  --color-chart-4: var(--chart-4);
  --color-chart-5: var(--chart-5);
  --color-sidebar: var(--sidebar);
  --color-sidebar-foreground: var(--sidebar-foreground);
  --color-sidebar-primary: var(--sidebar-primary);
  --color-sidebar-primary-foreground: var(--sidebar-primary-foreground);
  --color-sidebar-accent: var(--sidebar-accent);
  --color-sidebar-accent-foreground: var(--sidebar-accent-foreground);
  --color-sidebar-border: var(--sidebar-border);
  --color-sidebar-ring: var(--sidebar-ring);
}

@layer base {
  * {
    @apply border-border outline-ring/50;
  }
  body {
    @apply bg-background text-foreground;
  }

  /* Fix autofill background color */
  input:-webkit-autofill,
  input:-webkit-autofill:hover,
  input:-webkit-autofill:focus,
  input:-webkit-autofill:active {
    -webkit-box-shadow: 0 0 0 30px var(--background) inset !important;
    -webkit-text-fill-color: var(--foreground) !important;
    caret-color: var(--foreground) !important;
  }
}
</file>

<file path="apps/web/src/routes/chat.tsx">
import { useMutation, useQuery } from "@tanstack/react-query";
import {
  createFileRoute,
  Link,
  Outlet,
  redirect,
  useNavigate,
  useParams,
} from "@tanstack/react-router";
import {
  Bot,
  ChevronDown,
  ChevronRight,
  History,
  Loader2,
  MessageSquare,
  MoreVertical,
  Plus,
  Search,
  Trash2,
  User,
  X,
} from "lucide-react";
import { useEffect, useMemo, useRef, useState } from "react";
import { toast } from "sonner";
import { Button } from "@/components/ui/button";
import {
  DropdownMenu,
  DropdownMenuContent,
  DropdownMenuItem,
  DropdownMenuTrigger,
} from "@/components/ui/dropdown-menu";
import { Input } from "@/components/ui/input";
import { ScrollArea } from "@/components/ui/scroll-area";
import { Skeleton } from "@/components/ui/skeleton";
import { useHotkeys } from "@/hooks/use-hotkeys";
import { authClient } from "@/lib/auth-client";
import { cn } from "@/lib/utils";
import { queryClient, trpc, trpcClient } from "@/utils/trpc";

export const Route = createFileRoute("/chat")({
  component: ChatLayout,
  beforeLoad: async () => {
    const session = await authClient.getSession();
    if (!session.data?.user) {
      throw redirect({
        to: "/login",
      });
    }
    return { session };
  },
});

function formatRelativeTime(date: Date | string) {
  const now = new Date();
  const then = new Date(date);
  const diffMs = now.getTime() - then.getTime();
  const diffMins = Math.floor(diffMs / 60_000);
  const diffHours = Math.floor(diffMs / 3_600_000);
  const diffDays = Math.floor(diffMs / 86_400_000);

  if (diffMins < 1) {
    return "just now";
  }
  if (diffMins < 60) {
    return `${diffMins}m ago`;
  }
  if (diffHours < 24) {
    return `${diffHours}h ago`;
  }
  if (diffDays === 1) {
    return "yesterday";
  }
  if (diffDays < 7) {
    return `${diffDays}d ago`;
  }
  return then.toLocaleDateString();
}

function highlightMatch(text: string, query: string): React.ReactNode {
  if (!query) {
    return text;
  }
  const escaped = query.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
  const regex = new RegExp(`(${escaped})`, "gi");
  const parts = text.split(regex);
  return parts.map((part, index) =>
    regex.test(part) ? (
      // biome-ignore lint/suspicious/noArrayIndexKey: text highlighting produces stable array from split
      <mark className="bg-yellow-200 dark:bg-yellow-800" key={index}>
        {part}
      </mark>
    ) : (
      part
    )
  );
}

// biome-ignore lint/complexity/noExcessiveCognitiveComplexity: chat layout has multiple conditional UI states
function ChatLayout() {
  const navigate = useNavigate();
  const params = useParams({ strict: false });
  const currentChatId = params.chatId as string | undefined;

  const [searchQuery, setSearchQuery] = useState("");
  const [debouncedQuery, setDebouncedQuery] = useState("");
  const [expandedChats, setExpandedChats] = useState<Set<string>>(new Set());
  const [mobileHistoryOpen, setMobileHistoryOpen] = useState(false);
  const searchInputRef = useRef<HTMLInputElement>(null);

  useEffect(() => {
    const timer = setTimeout(() => {
      setDebouncedQuery(searchQuery);
    }, 300);
    return () => clearTimeout(timer);
  }, [searchQuery]);

  const currentChatQuery = useQuery({
    ...trpc.chat.get.queryOptions({ chatId: currentChatId ?? "" }),
    enabled: !!currentChatId,
    placeholderData: (prev) => prev,
  });

  const currentFileId = currentChatQuery.data?.fileId;

  const chatsQuery = useQuery({
    ...trpc.chat.list.queryOptions({ fileId: currentFileId }),
    enabled: !!currentFileId,
    placeholderData: (prev) => prev,
  });

  const searchResults = useQuery({
    ...trpc.chat.search.queryOptions({
      fileId: currentFileId ?? "",
      query: debouncedQuery,
    }),
    enabled: !!currentFileId && debouncedQuery.length > 0,
  });

  const isSearchMode = searchQuery.length > 0;

  function toggleChatExpanded(chatId: string) {
    setExpandedChats((prev) => {
      const next = new Set(prev);
      if (next.has(chatId)) {
        next.delete(chatId);
      } else {
        next.add(chatId);
      }
      return next;
    });
  }

  const createChatMutation = useMutation({
    mutationFn: (fileId: string) => trpcClient.chat.create.mutate({ fileId }),
    onSuccess: (data) => {
      queryClient.setQueryData(
        [["chat", "list"], { input: { fileId: currentFileId }, type: "query" }],
        (old: unknown) => {
          if (!(old && Array.isArray(old))) {
            return old;
          }
          return [
            {
              id: data.chatId,
              title: null,
              updatedAt: new Date(),
            },
            ...old,
          ];
        }
      );
      navigate({ to: "/chat/$chatId", params: { chatId: data.chatId } });
    },
    onError: () => {
      toast.error("Failed to create chat");
    },
  });

  const deleteChatMutation = useMutation({
    mutationFn: (chatId: string) => trpcClient.chat.delete.mutate({ chatId }),
    onSuccess: (_, deletedChatId) => {
      toast.success("Chat deleted");
      queryClient.invalidateQueries({ queryKey: [["chat", "list"]] });
      if (currentChatId === deletedChatId) {
        const remainingChats = chatsQuery.data?.filter(
          (c) => c.id !== deletedChatId
        );
        if (remainingChats && remainingChats.length > 0) {
          navigate({
            to: "/chat/$chatId",
            params: { chatId: remainingChats[0].id },
          });
        } else {
          navigate({ to: "/dashboard" });
        }
      }
    },
    onError: () => {
      toast.error("Failed to delete chat");
    },
  });

  const chats = chatsQuery.data ?? [];

  const hotkeys = useMemo(
    () => [
      {
        key: "j",
        ctrl: true,
        shift: true,
        callback: () => {
          if (currentFileId && !createChatMutation.isPending) {
            createChatMutation.mutate(currentFileId);
          }
        },
        enabled: !!currentFileId,
      },
      {
        key: "f",
        ctrl: true,
        shift: true,
        callback: () => {
          searchInputRef.current?.focus();
        },
      },
    ],
    [currentFileId, createChatMutation]
  );

  useHotkeys(hotkeys);

  function handleMobileNavigate() {
    setMobileHistoryOpen(false);
  }

  const sidebarContent = (
    <>
      <div className="flex h-14 items-center justify-between border-b px-3">
        <div className="min-w-0 flex-1">
          <h2 className="truncate font-semibold text-sm">Chats</h2>
        </div>
        <Button
          disabled={!currentFileId || createChatMutation.isPending}
          onClick={() => {
            if (currentFileId) {
              createChatMutation.mutate(currentFileId);
              handleMobileNavigate();
            }
          }}
          size="sm"
          variant="ghost"
        >
          {createChatMutation.isPending ? (
            <Loader2 className="h-4 w-4 animate-spin" />
          ) : (
            <Plus className="h-4 w-4" />
          )}
        </Button>
      </div>

      <div className="border-b p-2">
        <div className="relative">
          <Search className="-translate-y-1/2 absolute top-1/2 left-2 h-4 w-4 text-muted-foreground" />
          <Input
            className="h-8 pr-8 pl-8 text-sm"
            onChange={(e) => setSearchQuery(e.target.value)}
            placeholder="Search chats..."
            ref={searchInputRef}
            value={searchQuery}
          />
          {searchQuery && (
            <Button
              className="-translate-y-1/2 absolute top-1/2 right-1 h-6 w-6"
              onClick={() => setSearchQuery("")}
              size="icon"
              variant="ghost"
            >
              <X className="h-3 w-3" />
            </Button>
          )}
        </div>
      </div>

      <ScrollArea className="w-full flex-1">
        <div className="w-full">
          {isSearchMode ? (
            searchResults.isLoading ? (
              <div className="space-y-2 p-2">
                <Skeleton className="h-14 w-full" />
                <Skeleton className="h-14 w-full" />
              </div>
            ) : (searchResults.data?.chats.length ?? 0) === 0 ? (
              <div className="p-4 text-center text-muted-foreground text-sm">
                <Search className="mx-auto mb-2 h-8 w-8 opacity-50" />
                <p>No results found</p>
              </div>
            ) : (
              <div className="space-y-1 p-2">
                {searchResults.data?.chats.map((searchChat) => (
                  <div
                    className="overflow-hidden rounded-md border bg-background"
                    key={searchChat.id}
                  >
                    <button
                      className={cn(
                        "flex w-full items-center gap-2 overflow-hidden p-2 text-left hover:bg-muted/50",
                        currentChatId === searchChat.id && "bg-muted/50"
                      )}
                      onClick={() => {
                        navigate({
                          to: "/chat/$chatId",
                          params: { chatId: searchChat.id },
                        });
                        handleMobileNavigate();
                      }}
                      type="button"
                    >
                      <MessageSquare className="h-4 w-4 shrink-0 text-muted-foreground" />
                      <div className="min-w-0 flex-1 overflow-hidden">
                        <p className="truncate font-medium text-sm">
                          {highlightMatch(
                            searchChat.title || "New chat",
                            debouncedQuery
                          )}
                        </p>
                        <p className="text-muted-foreground text-xs">
                          {searchChat.matchingMessages.length} match
                          {searchChat.matchingMessages.length !== 1 && "es"}
                        </p>
                      </div>
                      <Button
                        className="h-6 w-6 shrink-0"
                        onClick={(e) => {
                          e.stopPropagation();
                          toggleChatExpanded(searchChat.id);
                        }}
                        size="icon"
                        variant="ghost"
                      >
                        {expandedChats.has(searchChat.id) ? (
                          <ChevronDown className="h-3 w-3" />
                        ) : (
                          <ChevronRight className="h-3 w-3" />
                        )}
                      </Button>
                    </button>
                    {expandedChats.has(searchChat.id) && (
                      <div className="space-y-2 border-t bg-muted/30 p-2">
                        {searchChat.matchingMessages.map((msg) => (
                          <div
                            className="flex items-start gap-2 text-xs"
                            key={msg.id}
                          >
                            {msg.role === "user" ? (
                              <User className="mt-0.5 h-3 w-3 shrink-0 text-muted-foreground" />
                            ) : (
                              <Bot className="mt-0.5 h-3 w-3 shrink-0 text-muted-foreground" />
                            )}
                            <p className="line-clamp-2 text-muted-foreground">
                              {highlightMatch(msg.content, debouncedQuery)}
                            </p>
                          </div>
                        ))}
                      </div>
                    )}
                  </div>
                ))}
              </div>
            )
          ) : chatsQuery.isLoading ? (
            <div className="space-y-2 p-2">
              <Skeleton className="h-14 w-full" />
              <Skeleton className="h-14 w-full" />
              <Skeleton className="h-14 w-full" />
            </div>
          ) : chats.length === 0 ? (
            <div className="p-4 text-center text-muted-foreground text-sm">
              <MessageSquare className="mx-auto mb-2 h-8 w-8 opacity-50" />
              <p>No chats yet</p>
              <Button
                asChild
                className="mt-2"
                onClick={handleMobileNavigate}
                size="sm"
                variant="outline"
              >
                <Link to="/dashboard">Start from Dashboard</Link>
              </Button>
            </div>
          ) : (
            <div className="space-y-1 p-2">
              {chats.map((chatItem) => (
                <div
                  className={cn(
                    "group relative overflow-hidden rounded-md transition-colors hover:bg-muted",
                    currentChatId === chatItem.id && "bg-muted"
                  )}
                  key={chatItem.id}
                >
                  <Link
                    className="block overflow-hidden p-2"
                    onClick={handleMobileNavigate}
                    params={{ chatId: chatItem.id }}
                    to="/chat/$chatId"
                  >
                    <div className="flex items-start gap-2 overflow-hidden">
                      <MessageSquare className="mt-0.5 h-4 w-4 shrink-0 text-muted-foreground" />
                      <div className="min-w-0 flex-1 overflow-hidden">
                        <p className="truncate font-medium text-sm">
                          {chatItem.title || "New chat"}
                        </p>
                        <p className="text-muted-foreground text-xs">
                          {formatRelativeTime(chatItem.updatedAt)}
                        </p>
                      </div>
                    </div>
                  </Link>
                  <DropdownMenu>
                    <DropdownMenuTrigger asChild>
                      <Button
                        className="absolute top-1 right-1 h-6 w-6 opacity-0 group-hover:opacity-100"
                        size="icon"
                        variant="ghost"
                      >
                        <MoreVertical className="h-3 w-3" />
                      </Button>
                    </DropdownMenuTrigger>
                    <DropdownMenuContent align="end">
                      <DropdownMenuItem
                        disabled={deleteChatMutation.isPending}
                        onClick={() => deleteChatMutation.mutate(chatItem.id)}
                        variant="destructive"
                      >
                        <Trash2 className="mr-2 h-4 w-4" />
                        Delete
                      </DropdownMenuItem>
                    </DropdownMenuContent>
                  </DropdownMenu>
                </div>
              ))}
            </div>
          )}
        </div>
      </ScrollArea>
    </>
  );

  return (
    <div className="flex h-full flex-col md:flex-row">
      {/* Mobile header with history button */}
      <div className="flex h-12 items-center justify-between border-b bg-muted/30 px-3 md:hidden">
        <h2 className="font-semibold text-sm">Chat</h2>
        <div className="flex items-center gap-1">
          <Button
            disabled={!currentFileId || createChatMutation.isPending}
            onClick={() =>
              currentFileId && createChatMutation.mutate(currentFileId)
            }
            size="sm"
            variant="ghost"
          >
            {createChatMutation.isPending ? (
              <Loader2 className="h-4 w-4 animate-spin" />
            ) : (
              <Plus className="h-4 w-4" />
            )}
          </Button>
          <Button
            onClick={() => setMobileHistoryOpen(true)}
            size="sm"
            variant="ghost"
          >
            <History className="h-4 w-4" />
          </Button>
        </div>
      </div>

      {/* Mobile history drawer */}
      {mobileHistoryOpen && (
        <>
          <button
            aria-label="Close chat history"
            className="fixed inset-0 z-40 cursor-default border-none bg-black/50 md:hidden"
            onClick={() => setMobileHistoryOpen(false)}
            type="button"
          />
          <aside className="fixed inset-y-0 right-0 z-50 flex w-72 flex-col bg-card shadow-lg md:hidden">
            <div className="flex h-14 items-center justify-between border-b px-3">
              <h2 className="font-semibold">Chat History</h2>
              <Button
                onClick={() => setMobileHistoryOpen(false)}
                size="icon"
                variant="ghost"
              >
                <X className="h-5 w-5" />
              </Button>
            </div>
            <div className="border-b p-2">
              <div className="relative">
                <Search className="-translate-y-1/2 absolute top-1/2 left-2 h-4 w-4 text-muted-foreground" />
                <Input
                  className="h-8 pr-8 pl-8 text-sm"
                  onChange={(e) => setSearchQuery(e.target.value)}
                  placeholder="Search chats..."
                  value={searchQuery}
                />
                {searchQuery && (
                  <Button
                    className="-translate-y-1/2 absolute top-1/2 right-1 h-6 w-6"
                    onClick={() => setSearchQuery("")}
                    size="icon"
                    variant="ghost"
                  >
                    <X className="h-3 w-3" />
                  </Button>
                )}
              </div>
            </div>
            <ScrollArea className="w-full flex-1">
              <div className="w-full">
                {chatsQuery.isLoading ? (
                  <div className="space-y-2 p-2">
                    <Skeleton className="h-14 w-full" />
                    <Skeleton className="h-14 w-full" />
                    <Skeleton className="h-14 w-full" />
                  </div>
                ) : chats.length === 0 ? (
                  <div className="p-4 text-center text-muted-foreground text-sm">
                    <MessageSquare className="mx-auto mb-2 h-8 w-8 opacity-50" />
                    <p>No chats yet</p>
                  </div>
                ) : (
                  <div className="space-y-1 p-2">
                    {chats.map((chatItem) => (
                      <Link
                        className={cn(
                          "block overflow-hidden rounded-md p-2 transition-colors hover:bg-muted",
                          currentChatId === chatItem.id && "bg-muted"
                        )}
                        key={chatItem.id}
                        onClick={handleMobileNavigate}
                        params={{ chatId: chatItem.id }}
                        to="/chat/$chatId"
                      >
                        <div className="flex items-start gap-2 overflow-hidden">
                          <MessageSquare className="mt-0.5 h-4 w-4 shrink-0 text-muted-foreground" />
                          <div className="min-w-0 flex-1 overflow-hidden">
                            <p className="truncate font-medium text-sm">
                              {chatItem.title || "New chat"}
                            </p>
                            <p className="text-muted-foreground text-xs">
                              {formatRelativeTime(chatItem.updatedAt)}
                            </p>
                          </div>
                        </div>
                      </Link>
                    ))}
                  </div>
                )}
              </div>
            </ScrollArea>
          </aside>
        </>
      )}

      {/* Desktop sidebar */}
      <div className="hidden w-64 min-w-0 flex-col overflow-hidden border-r bg-muted/30 md:flex">
        {sidebarContent}
      </div>

      <div className="flex-1 overflow-hidden">
        <Outlet />
      </div>
    </div>
  );
}
</file>

<file path="apps/web/src/routes/files.tsx">
import { createFileRoute, redirect } from "@tanstack/react-router";
import { useMemo, useState } from "react";
import { FileList } from "@/components/files/file-list";
import { FileUploadDialog } from "@/components/files/file-upload-dialog";
import { useHotkeys } from "@/hooks/use-hotkeys";
import { authClient } from "@/lib/auth-client";

export const Route = createFileRoute("/files")({
  component: FilesPage,
  beforeLoad: async () => {
    const session = await authClient.getSession();
    if (!session.data?.user) {
      throw redirect({
        to: "/login",
      });
    }
    return { session };
  },
});

function FilesPage() {
  const [uploadDialogOpen, setUploadDialogOpen] = useState(false);

  const hotkeys = useMemo(
    () => [
      {
        key: "u",
        ctrl: true,
        shift: true,
        callback: () => setUploadDialogOpen(true),
      },
    ],
    []
  );

  useHotkeys(hotkeys);

  return (
    <div className="container mx-auto px-4 py-6 md:py-8">
      <div className="mb-6 flex flex-col gap-4 sm:mb-8 sm:flex-row sm:items-center sm:justify-between">
        <h1 className="font-bold text-2xl md:text-3xl">Documents</h1>
        <FileUploadDialog
          onOpenChange={setUploadDialogOpen}
          open={uploadDialogOpen}
        />
      </div>
      <FileList />
    </div>
  );
}
</file>

<file path="README.md">
# xquery

A modern TypeScript monorepo for querying and managing files with OpenAI integration.

## Features

- **TypeScript** - For type safety and improved developer experience
- **TanStack Router** - File-based routing with full type safety
- **TailwindCSS** - Utility-first CSS for rapid UI development
- **shadcn/ui** - Reusable UI components
- **Framer Motion** - Subtle, professional animations with accessibility support
- **Hono** - Lightweight, performant server framework
- **tRPC** - End-to-end type-safe APIs
- **Bun** - Runtime environment
- **Drizzle** - TypeScript-first ORM
- **PostgreSQL** - Database engine
- **Better-Auth** - Authentication
- **OpenAI** - File chat and vector store integration
- **Ultracite** - Zero-config Biome preset for linting and formatting
- **Husky** - Git hooks for code quality
- **Turborepo** - Optimized monorepo build system

## Prerequisites

This project requires [Bun](https://bun.sh) as the package manager and runtime. **npm and yarn are not supported** due to bun-specific features:

- `catalog:` protocol for shared dependency versions
- `workspace:*` dependency resolution
- Bun's native hot reloading and compilation

Install Bun:

```bash
# macOS/Linux
curl -fsSL https://bun.sh/install | bash

# Windows
powershell -c "irm bun.sh/install.ps1 | iex"
```

## Getting Started

First, install the dependencies:

```bash
bun install
```
## Database Setup

This project uses PostgreSQL with Drizzle ORM.

1. Make sure you have a PostgreSQL database set up.
2. Update your `apps/server/.env` file with your PostgreSQL connection details.

3. Apply the schema to your database:
```bash
bun run db:push
```


Then, run the development server:

```bash
bun run dev
```

Open [http://localhost:3001](http://localhost:3001) in your browser to see the web application.
The API is running at [http://localhost:3000](http://localhost:3000).







## Project Structure

```
xquery/
 apps/
    web/                    # Frontend application (React + TanStack Router)
       src/
           components/     # React components
              files/      # File management components
              ui/         # shadcn/ui components
           hooks/          # Custom React hooks
           lib/            # Utility functions
           routes/         # TanStack Router file-based routes
    server/                 # Backend API (Hono)
 packages/
    api/                    # tRPC routers & business logic
       src/
           routers/        # tRPC route handlers (chat, files)
           lib/            # OpenAI integration
    auth/                   # Better-Auth configuration
    config/                 # Shared TypeScript config
    db/                     # Drizzle ORM & database schema
        src/
            schema/         # Database table definitions
            migrations/     # Database migrations
```

## Available Scripts

- `bun run dev`: Start all applications in development mode
- `bun run build`: Build all applications
- `bun run dev:web`: Start only the web application
- `bun run dev:server`: Start only the server
- `bun run check-types`: Check TypeScript types across all apps
- `bun run db:push`: Push schema changes to database
- `bun run db:studio`: Open database studio UI

## Code Quality

This project uses [Ultracite](https://github.com/haydenbleasel/ultracite), a zero-config Biome preset for linting and formatting.

```bash
# Check for issues
npx ultracite check

# Fix issues automatically
npx ultracite fix
```

## Server Deployment (Docker)

Due to a recent Vercel infrastructure change causing Hono.js functions to crash, the server is deployed via Docker instead.

### Build and Run

```bash
# Build the image
docker build -t xquery-server .

# Run with environment variables
docker run -p 3000:3000 --env-file apps/server/.env xquery-server
```

### Required Environment Variables

Create `apps/server/.env` with the following:

```env
BETTER_AUTH_SECRET=
BETTER_AUTH_URL=
CORS_ORIGIN=
INVITATION_CODE=
DATABASE_URL=
SUPABASE_URL=
SUPABASE_SERVICE_KEY=
OPENAI_API_KEY=
```

The server bundle is fully self-contained (all dependencies bundled via tsdown), resulting in a minimal Docker image.
</file>

<file path="turbo.json">
{
  "$schema": "https://turbo.build/schema.json",
  "ui": "tui",
  "tasks": {
    "build": {
      "dependsOn": ["^build"],
      "inputs": ["$TURBO_DEFAULT$", ".env*"],
      "outputs": ["dist/**"]
    },
    "server#build": {
      "dependsOn": ["^build"],
      "inputs": ["$TURBO_DEFAULT$", ".env*"],
      "outputs": ["dist/**"],
      "env": [
        "BETTER_AUTH_SECRET",
        "BETTER_AUTH_URL",
        "CORS_ORIGIN",
        "DATABASE_URL",
        "SUPABASE_URL",
        "SUPABASE_SERVICE_KEY",
        "OPENAI_API_KEY",
        "INVITATION_CODE"
      ]
    },
    "lint": {
      "dependsOn": ["^lint"]
    },
    "check-types": {
      "dependsOn": ["^check-types"]
    },
    "test": {
      "dependsOn": ["^build"],
      "inputs": ["$TURBO_DEFAULT$", "vitest.config.ts"],
      "outputs": ["coverage/**"]
    },
    "test:run": {
      "dependsOn": ["^build"],
      "inputs": ["$TURBO_DEFAULT$", "vitest.config.ts"],
      "outputs": ["coverage/**"]
    },
    "dev": {
      "cache": false,
      "persistent": true
    },
    "db:push": {
      "cache": false,
      "persistent": true
    },
    "db:studio": {
      "cache": false,
      "persistent": true
    },
    "db:migrate": {
      "cache": false,
      "persistent": true
    },
    "db:generate": {
      "cache": false,
      "persistent": true
    }
  }
}
</file>

<file path="apps/web/package.json">
{
  "name": "web",
  "version": "0.0.0",
  "private": true,
  "type": "module",
  "scripts": {
    "dev": "vite --port=3001",
    "build": "vite build",
    "serve": "vite preview",
    "start": "vite",
    "check-types": "tsc --noEmit",
    "test": "vitest",
    "test:run": "vitest run",
    "test:coverage": "vitest run --coverage"
  },
  "dependencies": {
    "@hookform/resolvers": "^5.1.1",
    "@radix-ui/react-alert-dialog": "^1.1.15",
    "@radix-ui/react-dialog": "^1.1.15",
    "@radix-ui/react-scroll-area": "^1.2.10",
    "@radix-ui/react-slot": "^1.2.4",
    "@tailwindcss/typography": "^0.5.19",
    "@tailwindcss/vite": "^4.0.15",
    "@tanstack/react-form": "^1.12.3",
    "@tanstack/react-query": "^5.85.5",
    "@tanstack/react-router": "^1.114.25",
    "@trpc/client": "catalog:",
    "@trpc/server": "catalog:",
    "@trpc/tanstack-react-query": "^11.5.0",
    "@xquery/api": "workspace:*",
    "@xquery/auth": "workspace:*",
    "better-auth": "catalog:",
    "class-variance-authority": "^0.7.1",
    "clsx": "^2.1.1",
    "framer-motion": "^12.23.26",
    "lucide-react": "^0.473.0",
    "next-themes": "^0.4.6",
    "radix-ui": "^1.4.2",
    "react": "19.1.2",
    "react-dom": "19.1.2",
    "react-markdown": "^10.1.0",
    "remark-gfm": "^4.0.1",
    "sonner": "^2.0.5",
    "tailwind-merge": "^3.3.1",
    "tw-animate-css": "^1.2.5"
  },
  "devDependencies": {
    "@tanstack/react-query-devtools": "^5.85.5",
    "@tanstack/react-router-devtools": "^1.114.27",
    "@tanstack/router-plugin": "^1.114.27",
    "@testing-library/jest-dom": "^6.9.1",
    "@testing-library/react": "^16.3.0",
    "@testing-library/user-event": "^14.6.1",
    "@types/node": "^22.13.13",
    "@types/react": "~19.1.10",
    "@types/react-dom": "^19.0.4",
    "@vitejs/plugin-react": "^4.3.4",
    "@vitest/coverage-v8": "^4.0.15",
    "@xquery/config": "workspace:*",
    "happy-dom": "^20.0.11",
    "postcss": "^8.5.3",
    "tailwindcss": "^4.0.15",
    "typescript": "^5.8.3",
    "vite": "^6.2.2",
    "vitest": "^4.0.15"
  }
}
</file>

<file path="apps/web/src/routes/__root.tsx">
import type { QueryClient } from "@tanstack/react-query";
import { ReactQueryDevtools } from "@tanstack/react-query-devtools";
import {
  createRootRouteWithContext,
  HeadContent,
  Outlet,
  useRouterState,
} from "@tanstack/react-router";
import { TanStackRouterDevtools } from "@tanstack/react-router-devtools";
import { ErrorBoundary, NotFound } from "@/components/error-boundary";
import { KeyboardShortcutsDialog } from "@/components/keyboard-shortcuts-dialog";
import { MobileHeader, Sidebar } from "@/components/sidebar";
import { ThemeProvider } from "@/components/theme-provider";
import { Toaster } from "@/components/ui/sonner";
import type { trpc } from "@/utils/trpc";
import "../index.css";

const AUTH_ROUTES = ["/login"];

export type RouterAppContext = {
  trpc: typeof trpc;
  queryClient: QueryClient;
};

export const Route = createRootRouteWithContext<RouterAppContext>()({
  component: RootComponent,
  errorComponent: ErrorBoundary,
  notFoundComponent: NotFound,
  head: () => ({
    meta: [
      {
        title: "XQuery",
      },
      {
        name: "description",
        content: "XQuery is a web application",
      },
    ],
    links: [
      {
        rel: "icon",
        href: "/favicon.ico",
      },
    ],
  }),
});

function RootComponent() {
  const pathname = useRouterState({ select: (s) => s.location.pathname });
  const isAuthRoute = AUTH_ROUTES.includes(pathname);

  return (
    <>
      <HeadContent />
      <ThemeProvider
        attribute="class"
        defaultTheme="dark"
        disableTransitionOnChange
        storageKey="vite-ui-theme"
      >
        {isAuthRoute ? (
          <main className="h-svh">
            <Outlet />
          </main>
        ) : (
          <KeyboardShortcutsDialog>
            <div className="flex h-svh flex-col md:flex-row">
              <MobileHeader />
              <Sidebar />
              <main className="flex-1 overflow-auto">
                <Outlet />
              </main>
            </div>
          </KeyboardShortcutsDialog>
        )}
        <Toaster richColors />
      </ThemeProvider>
      <TanStackRouterDevtools position="bottom-left" />
      <ReactQueryDevtools buttonPosition="bottom-right" position="bottom" />
    </>
  );
}
</file>

<file path="apps/web/src/routes/dashboard.tsx">
import { useQuery } from "@tanstack/react-query";
import { createFileRoute, Link, redirect } from "@tanstack/react-router";
import { Clock, FileText, MessageSquare, Wifi, WifiOff } from "lucide-react";
import { StaggerContainer, StaggerItem } from "@/components/motion";
import { Card, CardContent, CardHeader, CardTitle } from "@/components/ui/card";
import { Skeleton } from "@/components/ui/skeleton";
import { authClient } from "@/lib/auth-client";
import { trpc } from "@/utils/trpc";

export const Route = createFileRoute("/dashboard")({
  component: DashboardPage,
  beforeLoad: async () => {
    const session = await authClient.getSession();
    if (!session.data?.user) {
      throw redirect({
        to: "/login",
      });
    }
    return { session };
  },
});

function formatRelativeTime(date: Date | string) {
  const now = new Date();
  const then = new Date(date);
  const diffMs = now.getTime() - then.getTime();
  const diffMins = Math.floor(diffMs / (1000 * 60));
  const diffHours = Math.floor(diffMs / (1000 * 60 * 60));
  const diffDays = Math.floor(diffMs / (1000 * 60 * 60 * 24));

  if (diffMins < 1) {
    return "Just now";
  }
  if (diffMins < 60) {
    return `${diffMins} minute${diffMins === 1 ? "" : "s"} ago`;
  }
  if (diffHours < 24) {
    return `${diffHours} hour${diffHours === 1 ? "" : "s"} ago`;
  }
  if (diffDays < 7) {
    return `${diffDays} day${diffDays === 1 ? "" : "s"} ago`;
  }
  return new Intl.DateTimeFormat("en-US", {
    month: "short",
    day: "numeric",
    year: "numeric",
  }).format(then);
}

function FilesStatCard({
  count,
  isLoading,
}: {
  count: number;
  isLoading: boolean;
}) {
  return (
    <Card>
      <CardHeader className="flex flex-row items-center justify-between space-y-0 pb-2">
        <CardTitle className="font-medium text-sm">Total Files</CardTitle>
        <FileText className="h-4 w-4 text-muted-foreground" />
      </CardHeader>
      <CardContent>
        {isLoading ? (
          <Skeleton className="h-8 w-16" />
        ) : (
          <>
            <div className="font-bold text-2xl">{count}</div>
            <p className="text-muted-foreground text-xs">
              <Link className="hover:underline" to="/files">
                View all files
              </Link>
            </p>
          </>
        )}
      </CardContent>
    </Card>
  );
}

function ChatsStatCard({
  count,
  isLoading,
}: {
  count: number;
  isLoading: boolean;
}) {
  return (
    <Card>
      <CardHeader className="flex flex-row items-center justify-between space-y-0 pb-2">
        <CardTitle className="font-medium text-sm">Total Chats</CardTitle>
        <MessageSquare className="h-4 w-4 text-muted-foreground" />
      </CardHeader>
      <CardContent>
        {isLoading ? (
          <Skeleton className="h-8 w-16" />
        ) : (
          <>
            <div className="font-bold text-2xl">{count}</div>
            <p className="text-muted-foreground text-xs">
              Conversations with your documents
            </p>
          </>
        )}
      </CardContent>
    </Card>
  );
}

function LastActivityCard({
  lastChat,
  isLoading,
}: {
  lastChat: { createdAt: string; title: string | null } | null;
  isLoading: boolean;
}) {
  return (
    <Card>
      <CardHeader className="flex flex-row items-center justify-between space-y-0 pb-2">
        <CardTitle className="font-medium text-sm">Last Activity</CardTitle>
        <Clock className="h-4 w-4 text-muted-foreground" />
      </CardHeader>
      <CardContent>
        {isLoading ? (
          <Skeleton className="h-8 w-24" />
        ) : lastChat ? (
          <>
            <div className="font-bold text-2xl">
              {formatRelativeTime(lastChat.createdAt)}
            </div>
            <p className="truncate text-muted-foreground text-xs">
              {lastChat.title || "Untitled chat"}
            </p>
          </>
        ) : (
          <>
            <div className="font-bold text-2xl">No activity</div>
            <p className="text-muted-foreground text-xs">
              Start a chat to begin
            </p>
          </>
        )}
      </CardContent>
    </Card>
  );
}

function ApiStatusCard({
  isOnline,
  isLoading,
}: {
  isOnline: boolean;
  isLoading: boolean;
}) {
  return (
    <Card>
      <CardHeader className="flex flex-row items-center justify-between space-y-0 pb-2">
        <CardTitle className="font-medium text-sm">API Status</CardTitle>
        {isOnline ? (
          <Wifi className="h-4 w-4 text-green-500" />
        ) : (
          <WifiOff className="h-4 w-4 text-destructive" />
        )}
      </CardHeader>
      <CardContent>
        {isLoading ? (
          <Skeleton className="h-8 w-20" />
        ) : (
          <>
            <div className="flex items-center gap-2 font-bold text-2xl">
              <div
                className={`h-2 w-2 rounded-full ${isOnline ? "bg-green-500" : "bg-destructive"}`}
              />
              {isOnline ? "Online" : "Offline"}
            </div>
            <p className="text-muted-foreground text-xs">
              {isOnline ? "All systems operational" : "Connection issues"}
            </p>
          </>
        )}
      </CardContent>
    </Card>
  );
}

function DashboardPage() {
  const healthCheck = useQuery(trpc.healthCheck.queryOptions());
  const filesQuery = useQuery(trpc.files.list.queryOptions({ limit: 50 }));
  const chatsQuery = useQuery(trpc.chat.list.queryOptions({}));

  const files = filesQuery.data ?? [];
  const chats = chatsQuery.data ?? [];
  const lastChat = chats.length > 0 ? chats[0] : null;
  const isLoading = filesQuery.isLoading || chatsQuery.isLoading;

  return (
    <div className="container mx-auto px-4 py-6 md:py-8">
      <h1 className="mb-6 font-bold text-2xl sm:mb-8 md:text-3xl">Dashboard</h1>

      <StaggerContainer className="grid gap-4 sm:gap-6 md:grid-cols-2 lg:grid-cols-4">
        <StaggerItem>
          <FilesStatCard count={files.length} isLoading={isLoading} />
        </StaggerItem>
        <StaggerItem>
          <ChatsStatCard count={chats.length} isLoading={isLoading} />
        </StaggerItem>
        <StaggerItem>
          <LastActivityCard isLoading={isLoading} lastChat={lastChat} />
        </StaggerItem>
        <StaggerItem>
          <ApiStatusCard
            isLoading={healthCheck.isLoading}
            isOnline={!!healthCheck.data}
          />
        </StaggerItem>
      </StaggerContainer>
    </div>
  );
}
</file>

<file path="apps/web/src/components/files/file-list.tsx">
import { useMutation, useQuery } from "@tanstack/react-query";
import { useNavigate } from "@tanstack/react-router";
import { AnimatePresence, motion } from "framer-motion";
import {
  Download,
  Files,
  FileText,
  Info,
  MessageSquare,
  MoreVertical,
  Pencil,
  Sparkles,
  Trash2,
} from "lucide-react";
import { useState } from "react";
import { toast } from "sonner";
import {
  AlertDialog,
  AlertDialogAction,
  AlertDialogCancel,
  AlertDialogContent,
  AlertDialogDescription,
  AlertDialogFooter,
  AlertDialogHeader,
  AlertDialogTitle,
} from "@/components/ui/alert-dialog";
import { Button } from "@/components/ui/button";
import { Card, CardContent, CardHeader, CardTitle } from "@/components/ui/card";
import {
  Dialog,
  DialogContent,
  DialogFooter,
  DialogHeader,
  DialogTitle,
} from "@/components/ui/dialog";
import {
  DropdownMenu,
  DropdownMenuContent,
  DropdownMenuItem,
  DropdownMenuTrigger,
} from "@/components/ui/dropdown-menu";
import { Input } from "@/components/ui/input";
import { Label } from "@/components/ui/label";
import { Skeleton } from "@/components/ui/skeleton";
import { useReducedMotion } from "@/hooks/use-reduced-motion";
import { staggerContainerVariants, staggerItemVariants } from "@/lib/motion";
import { queryClient, trpc, trpcClient } from "@/utils/trpc";

const FILE_TYPE_LABELS: Record<string, string> = {
  "application/pdf": "PDF",
  "application/vnd.openxmlformats-officedocument.wordprocessingml.document":
    "DOCX",
  "text/plain": "TXT",
  "text/markdown": "MD",
};

function formatFileSize(bytes: number) {
  if (bytes < 1024) {
    return `${bytes} B`;
  }
  if (bytes < 1024 * 1024) {
    return `${(bytes / 1024).toFixed(1)} KB`;
  }
  return `${(bytes / (1024 * 1024)).toFixed(1)} MB`;
}

function formatDate(date: Date | string) {
  return new Intl.DateTimeFormat("en-US", {
    month: "short",
    day: "numeric",
    year: "numeric",
    hour: "numeric",
    minute: "2-digit",
  }).format(new Date(date));
}

type FileItemProps = {
  file: {
    id: string;
    name: string;
    mimeType: string;
    size: number;
    createdAt: Date | string;
    openaiFileId: string | null;
  };
  existingChatId?: string;
  onRename: (file: { id: string; name: string }) => void;
  onDelete: (file: { id: string; name: string }) => void;
  onViewDetails: (fileId: string) => void;
  onDownload: (fileId: string) => void;
  onStartChat: (fileId: string) => void;
  onViewChat: (chatId: string) => void;
  isDownloading: boolean;
  isCreatingChat: boolean;
};

function FileItem({
  file,
  existingChatId,
  onRename,
  onDelete,
  onViewDetails,
  onDownload,
  onStartChat,
  onViewChat,
  isDownloading,
  isCreatingChat,
}: FileItemProps) {
  return (
    <div className="flex items-center justify-between gap-2 rounded-md border p-2 transition-colors hover:bg-muted/50 sm:gap-3 sm:p-3">
      <button
        className="flex min-w-0 flex-1 cursor-pointer items-center gap-2 text-left sm:gap-3"
        onClick={() => {
          if (existingChatId) {
            onViewChat(existingChatId);
          } else {
            onStartChat(file.id);
          }
        }}
        type="button"
      >
        <div className="flex h-8 w-8 shrink-0 items-center justify-center rounded-md bg-primary/10 font-medium text-primary text-xs sm:h-10 sm:w-10">
          {FILE_TYPE_LABELS[file.mimeType] || "FILE"}
        </div>
        <div className="min-w-0 flex-1">
          <div className="flex items-center gap-2">
            <p className="truncate font-medium text-sm sm:text-base">
              {file.name}
            </p>
            {file.openaiFileId && (
              <span className="shrink-0" title="Synced to AI">
                <Sparkles className="h-3 w-3 text-amber-500" />
              </span>
            )}
          </div>
          <p className="truncate text-muted-foreground text-xs">
            {formatFileSize(file.size)} &middot; {formatDate(file.createdAt)}
          </p>
        </div>
      </button>

      <DropdownMenu>
        <DropdownMenuTrigger asChild>
          <Button className="shrink-0" size="sm" variant="ghost">
            <MoreVertical className="h-4 w-4" />
          </Button>
        </DropdownMenuTrigger>
        <DropdownMenuContent align="end">
          <DropdownMenuItem
            disabled={isDownloading}
            onClick={() => onDownload(file.id)}
          >
            <Download className="mr-2 h-4 w-4" />
            Download
          </DropdownMenuItem>
          <DropdownMenuItem
            onClick={() => onRename({ id: file.id, name: file.name })}
          >
            <Pencil className="mr-2 h-4 w-4" />
            Rename
          </DropdownMenuItem>
          <DropdownMenuItem onClick={() => onViewDetails(file.id)}>
            <Info className="mr-2 h-4 w-4" />
            View Details
          </DropdownMenuItem>
          {existingChatId ? (
            <DropdownMenuItem onClick={() => onViewChat(existingChatId)}>
              <MessageSquare className="mr-2 h-4 w-4" />
              View Chats
            </DropdownMenuItem>
          ) : (
            <DropdownMenuItem
              disabled={isCreatingChat}
              onClick={() => onStartChat(file.id)}
            >
              <MessageSquare className="mr-2 h-4 w-4" />
              Start Chat
            </DropdownMenuItem>
          )}
          <DropdownMenuItem
            onClick={() => onDelete({ id: file.id, name: file.name })}
            variant="destructive"
          >
            <Trash2 className="mr-2 h-4 w-4" />
            Delete
          </DropdownMenuItem>
        </DropdownMenuContent>
      </DropdownMenu>
    </div>
  );
}

type RenameDialogProps = {
  open: boolean;
  onOpenChange: (open: boolean) => void;
  fileName: string;
  onNameChange: (name: string) => void;
  onSubmit: (e: React.FormEvent) => void;
  isPending: boolean;
};

function RenameDialog({
  open,
  onOpenChange,
  fileName,
  onNameChange,
  onSubmit,
  isPending,
}: RenameDialogProps) {
  return (
    <Dialog onOpenChange={onOpenChange} open={open}>
      <DialogContent className="sm:max-w-md">
        <DialogHeader>
          <DialogTitle>Rename File</DialogTitle>
        </DialogHeader>
        <form onSubmit={onSubmit}>
          <div className="space-y-4">
            <div className="space-y-2">
              <Label htmlFor="rename-input">Name</Label>
              <Input
                autoFocus
                disabled={isPending}
                id="rename-input"
                onChange={(e) => onNameChange(e.target.value)}
                placeholder="Enter file name"
                value={fileName}
              />
            </div>
          </div>
          <DialogFooter className="mt-4">
            <Button
              disabled={isPending}
              onClick={() => onOpenChange(false)}
              type="button"
              variant="outline"
            >
              Cancel
            </Button>
            <Button disabled={!fileName.trim() || isPending} type="submit">
              {isPending ? "Saving..." : "Save"}
            </Button>
          </DialogFooter>
        </form>
      </DialogContent>
    </Dialog>
  );
}

type FileDetailsDialogProps = {
  open: boolean;
  onOpenChange: (open: boolean) => void;
  file: {
    id: string;
    name: string;
    originalFilename: string;
    mimeType: string;
    size: number;
    createdAt: Date | string;
    openaiFileId: string | null;
  } | null;
  isLoading: boolean;
};

function FileDetailsDialog({
  open,
  onOpenChange,
  file,
  isLoading,
}: FileDetailsDialogProps) {
  return (
    <Dialog onOpenChange={onOpenChange} open={open}>
      <DialogContent className="sm:max-w-md">
        <DialogHeader>
          <DialogTitle>File Details</DialogTitle>
        </DialogHeader>
        {isLoading ? (
          <div className="space-y-3">
            <Skeleton className="h-5 w-full" />
            <Skeleton className="h-5 w-full" />
            <Skeleton className="h-5 w-full" />
          </div>
        ) : file ? (
          <div className="space-y-3 text-sm">
            <div className="flex justify-between">
              <span className="text-muted-foreground">Name</span>
              <span className="font-medium">{file.name}</span>
            </div>
            <div className="flex justify-between">
              <span className="text-muted-foreground">Original Filename</span>
              <span className="font-medium">{file.originalFilename}</span>
            </div>
            <div className="flex justify-between">
              <span className="text-muted-foreground">Type</span>
              <span className="font-medium">
                {FILE_TYPE_LABELS[file.mimeType] || file.mimeType}
              </span>
            </div>
            <div className="flex justify-between">
              <span className="text-muted-foreground">Size</span>
              <span className="font-medium">{formatFileSize(file.size)}</span>
            </div>
            <div className="flex justify-between">
              <span className="text-muted-foreground">Uploaded</span>
              <span className="font-medium">{formatDate(file.createdAt)}</span>
            </div>
            <div className="flex justify-between">
              <span className="text-muted-foreground">AI Sync Status</span>
              <span className="font-medium">
                {file.openaiFileId ? (
                  <span className="flex items-center gap-1 text-green-600 dark:text-green-400">
                    <Sparkles className="h-3 w-3" />
                    Synced
                  </span>
                ) : (
                  <span className="text-muted-foreground">Not synced</span>
                )}
              </span>
            </div>
            <div className="flex justify-between">
              <span className="text-muted-foreground">File ID</span>
              <span className="font-medium font-mono text-xs">{file.id}</span>
            </div>
          </div>
        ) : null}
        <DialogFooter>
          <Button onClick={() => onOpenChange(false)} variant="outline">
            Close
          </Button>
        </DialogFooter>
      </DialogContent>
    </Dialog>
  );
}

type DeleteDialogProps = {
  open: boolean;
  onOpenChange: (open: boolean) => void;
  fileName: string | undefined;
  onConfirm: () => void;
  isPending: boolean;
};

function DeleteDialog({
  open,
  onOpenChange,
  fileName,
  onConfirm,
  isPending,
}: DeleteDialogProps) {
  return (
    <AlertDialog
      onOpenChange={(newOpen) => {
        if (!isPending) {
          onOpenChange(newOpen);
        }
      }}
      open={open}
    >
      <AlertDialogContent>
        <AlertDialogHeader>
          <AlertDialogTitle>Delete File</AlertDialogTitle>
          <AlertDialogDescription>
            Are you sure you want to delete "{fileName}"? This action cannot be
            undone.
          </AlertDialogDescription>
        </AlertDialogHeader>
        <AlertDialogFooter>
          <AlertDialogCancel disabled={isPending}>Cancel</AlertDialogCancel>
          <AlertDialogAction disabled={isPending} onClick={onConfirm}>
            {isPending ? "Deleting..." : "Delete"}
          </AlertDialogAction>
        </AlertDialogFooter>
      </AlertDialogContent>
    </AlertDialog>
  );
}

export function FileList() {
  const navigate = useNavigate();
  const prefersReducedMotion = useReducedMotion();
  const [renameDialogOpen, setRenameDialogOpen] = useState(false);
  const [fileToRename, setFileToRename] = useState<{
    id: string;
    name: string;
  } | null>(null);
  const [newName, setNewName] = useState("");
  const [detailsDialogOpen, setDetailsDialogOpen] = useState(false);
  const [fileToView, setFileToView] = useState<string | null>(null);
  const [deleteDialogOpen, setDeleteDialogOpen] = useState(false);
  const [fileToDelete, setFileToDelete] = useState<{
    id: string;
    name: string;
  } | null>(null);

  const fileDetailsQuery = useQuery({
    ...trpc.files.get.queryOptions({ fileId: fileToView ?? "" }),
    enabled: !!fileToView && detailsDialogOpen,
  });

  const filesQuery = useQuery(trpc.files.list.queryOptions({ limit: 50 }));
  const chatsQuery = useQuery(trpc.chat.list.queryOptions({}));

  const chatsByFileId = new Map<string, string>();
  for (const chat of chatsQuery.data ?? []) {
    if (!chatsByFileId.has(chat.fileId)) {
      chatsByFileId.set(chat.fileId, chat.id);
    }
  }

  const renameMutation = useMutation({
    mutationFn: ({ fileId, name }: { fileId: string; name: string }) =>
      trpcClient.files.rename.mutate({ fileId, name }),
    onSuccess: () => {
      toast.success("File renamed");
      queryClient.invalidateQueries({ queryKey: [["files", "list"]] });
      setRenameDialogOpen(false);
      setFileToRename(null);
      setNewName("");
    },
    onError: () => {
      toast.error("Failed to rename file");
    },
  });

  const deleteMutation = useMutation({
    mutationFn: (fileId: string) => trpcClient.files.delete.mutate({ fileId }),
    onSuccess: () => {
      toast.success("File deleted");
      queryClient.invalidateQueries({ queryKey: [["files", "list"]] });
      setDeleteDialogOpen(false);
      setFileToDelete(null);
    },
    onError: () => {
      toast.error("Failed to delete file");
    },
  });

  const downloadMutation = useMutation({
    mutationFn: async (fileId: string) => {
      const result = await trpcClient.files.getDownloadUrl.mutate({ fileId });
      return result.url;
    },
    onSuccess: (url) => {
      window.open(url, "_blank", "noopener,noreferrer");
    },
    onError: () => {
      toast.error("Failed to get download link");
    },
  });

  const createChatMutation = useMutation({
    mutationFn: (fileId: string) => trpcClient.chat.create.mutate({ fileId }),
    onSuccess: (data) => {
      queryClient.setQueryData(
        [["chat", "get"], { input: { chatId: data.chatId }, type: "query" }],
        {
          id: data.chatId,
          fileId: data.fileId,
          fileName: data.fileName,
          title: data.title,
          messages: [],
        }
      );
      queryClient.invalidateQueries({ queryKey: [["chat", "list"]] });
      navigate({ to: "/chat/$chatId", params: { chatId: data.chatId } });
    },
    onError: (error) => {
      console.error("Failed to start chat:", error);
      toast.error("Failed to start chat");
    },
  });

  const handleOpenRenameDialog = (file: { id: string; name: string }) => {
    setFileToRename(file);
    setNewName(file.name);
    setRenameDialogOpen(true);
  };

  const handleOpenDetailsDialog = (fileId: string) => {
    setFileToView(fileId);
    setDetailsDialogOpen(true);
  };

  const handleOpenDeleteDialog = (file: { id: string; name: string }) => {
    setFileToDelete(file);
    setDeleteDialogOpen(true);
  };

  const handleRenameSubmit = (e: React.FormEvent) => {
    e.preventDefault();
    if (fileToRename && newName.trim()) {
      renameMutation.mutate({ fileId: fileToRename.id, name: newName.trim() });
    }
  };

  const handleDetailsDialogChange = (open: boolean) => {
    setDetailsDialogOpen(open);
    if (!open) {
      setFileToView(null);
    }
  };

  const handleDeleteDialogChange = (open: boolean) => {
    setDeleteDialogOpen(open);
    if (!open) {
      setFileToDelete(null);
    }
  };

  const handleViewChat = (chatId: string) => {
    navigate({ to: "/chat/$chatId", params: { chatId } });
  };

  if (filesQuery.isLoading) {
    return (
      <Card>
        <CardHeader>
          <CardTitle className="flex items-center gap-2">
            <Files className="h-5 w-5" />
            Your Files
          </CardTitle>
        </CardHeader>
        <CardContent className="space-y-3">
          <Skeleton className="h-16 w-full" />
          <Skeleton className="h-16 w-full" />
          <Skeleton className="h-16 w-full" />
        </CardContent>
      </Card>
    );
  }

  if (filesQuery.error) {
    return (
      <Card>
        <CardContent className="py-8 text-center text-muted-foreground">
          Failed to load files. Please try again.
        </CardContent>
      </Card>
    );
  }

  const files = filesQuery.data ?? [];

  return (
    <Card>
      <CardHeader>
        <CardTitle className="flex items-center gap-2">
          <Files className="h-5 w-5" />
          Your Files ({files.length})
        </CardTitle>
      </CardHeader>
      <CardContent>
        {files.length === 0 ? (
          <div className="py-8 text-center text-muted-foreground">
            <FileText className="mx-auto mb-4 h-12 w-12 opacity-50" />
            <p>No files uploaded yet</p>
            <p className="text-sm">Upload your first document to get started</p>
          </div>
        ) : (
          <motion.div
            animate="visible"
            className="space-y-2"
            initial={prefersReducedMotion ? false : "hidden"}
            variants={
              prefersReducedMotion ? undefined : staggerContainerVariants
            }
          >
            <AnimatePresence mode="popLayout">
              {files.map((file) => (
                <motion.div
                  exit={
                    prefersReducedMotion
                      ? undefined
                      : { opacity: 0, x: -20, transition: { duration: 0.15 } }
                  }
                  key={file.id}
                  layout={!prefersReducedMotion}
                  variants={
                    prefersReducedMotion ? undefined : staggerItemVariants
                  }
                >
                  <FileItem
                    existingChatId={chatsByFileId.get(file.id)}
                    file={file}
                    isCreatingChat={createChatMutation.isPending}
                    isDownloading={downloadMutation.isPending}
                    onDelete={handleOpenDeleteDialog}
                    onDownload={(fileId) => downloadMutation.mutate(fileId)}
                    onRename={handleOpenRenameDialog}
                    onStartChat={(fileId) => createChatMutation.mutate(fileId)}
                    onViewChat={handleViewChat}
                    onViewDetails={handleOpenDetailsDialog}
                  />
                </motion.div>
              ))}
            </AnimatePresence>
          </motion.div>
        )}
      </CardContent>

      <RenameDialog
        fileName={newName}
        isPending={renameMutation.isPending}
        onNameChange={setNewName}
        onOpenChange={setRenameDialogOpen}
        onSubmit={handleRenameSubmit}
        open={renameDialogOpen}
      />

      <FileDetailsDialog
        file={fileDetailsQuery.data ?? null}
        isLoading={fileDetailsQuery.isLoading}
        onOpenChange={handleDetailsDialogChange}
        open={detailsDialogOpen}
      />

      <DeleteDialog
        fileName={fileToDelete?.name}
        isPending={deleteMutation.isPending}
        onConfirm={() => {
          if (fileToDelete) {
            deleteMutation.mutate(fileToDelete.id);
          }
        }}
        onOpenChange={handleDeleteDialogChange}
        open={deleteDialogOpen}
      />
    </Card>
  );
}
</file>

</files>
